<!DOCTYPE html>
<html lang="en">
    <head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>
    
        Home
    
</title>
<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Index | 전은성 Dev</title>
<meta name="generator" content="Jekyll v4.4.1">
<meta property="og:title" content="Index">
<meta property="og:locale" content="en_US">
<meta name="description" content="개발 블로그">
<meta property="og:description" content="개발 블로그">
<link rel="canonical" href="http://localhost:4001/">
<meta property="og:url" content="http://localhost:4001/">
<meta property="og:site_name" content="전은성 Dev">
<meta property="og:type" content="article">
<meta property="article:published_time" content="1900-01-01T00:00:00+09:00">
<meta name="twitter:card" content="summary">
<meta property="twitter:title" content="Index">
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"WebSite","dateModified":"1900-01-01T00:00:00+09:00","datePublished":"1900-01-01T00:00:00+09:00","description":"개발 블로그","headline":"Index","name":"전은성 Dev","url":"http://localhost:4001/"}</script>
<!-- End Jekyll SEO tag -->


<link rel="shortcut icon" type="image/png" href="/assets/img/favicon.webp">
<style>
@font-face {
    font-family: 'Nunito Sans';
    font-style: normal;
    font-weight: 400;
    font-display: optional;
    src: local('Nunito Sans'),
         url("/assets/fonts/NunitoSans-Regular.woff2") format("woff2");
}

@font-face {
    font-family: 'Righteous';
    font-style: normal;
    font-weight: 600;
    font-display: optional;
    src: local('Righteous'),
         url("/assets/fonts/Righteous-Regular.woff2") format("woff2");
}

@font-face {
    font-family: 'Lato';
    font-style: normal;
    font-weight: 400;
    font-display: optional;
    src: local('Lato'),
         url("/assets/fonts/Lato-Regular.woff2") format("woff2");
}
</style>

<script src="/assets/js/fontfaceobserver.js" type="text/javascript"></script>
<script type="text/javascript">
    const nunitoObserver = new FontFaceObserver('Nunito Sans');
    const righteousObserver = new FontFaceObserver('Righteous');
    const latoObserver = new FontFaceObserver('Lato');
  
    Promise.all([
        nunitoObserver.load(),
        righteousObserver.load(),
        latoObserver.load(),
    ]).then(function(){
        document.documentElement.className += " fonts-loaded";
    });
</script>

<meta name="baseurl" content="">
<meta name="description" content="개발 블로그">
        <link rel="preload" href="/assets/img/profile.webp" as="image">
        <link rel="stylesheet" href="/assets/css/style.css">
        
    </head>
    <body>
        <script type="text/javascript">
            let currentTheme = localStorage.getItem('theme');
        
            document.body.classList[currentTheme === 'dark' ? 'add' : 'remove']('dark-theme');
        </script>
        <canvas id="stars" width="100%" height="100%"></canvas>
        <div class="sidebar sidebar-left">
    <div class="side-banner">
        <h1 class="site-tab">
            <a href="/" class="site-name">
                <img src="/assets/img/icon/house.webp" alt="" loading="lazy">
                <mark>전은성 Dev</mark>
            </a>
            <button id="btn-brightness" aria-label="brightness-button">
                <svg class="ico-dark" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 384 512"><path d="M223.5 32C100 32 0 132.3 0 256S100 480 223.5 480c60.6 0 115.5-24.2 155.8-63.4c5-4.9 6.3-12.5 3.1-18.7s-10.1-9.7-17-8.5c-9.8 1.7-19.8 2.6-30.1 2.6c-96.9 0-175.5-78.8-175.5-176c0-65.8 36-123.1 89.3-153.3c6.1-3.5 9.2-10.5 7.7-17.3s-7.3-11.9-14.3-12.5c-6.3-.5-12.6-.8-19-.8z"></path></svg>
                <svg class="ico-light" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 512 512"><path d="M361.5 1.2c5 2.1 8.6 6.6 9.6 11.9L391 121l107.9 19.8c5.3 1 9.8 4.6 11.9 9.6s1.5 10.7-1.6 15.2L446.9 256l62.3 90.3c3.1 4.5 3.7 10.2 1.6 15.2s-6.6 8.6-11.9 9.6L391 391 371.1 498.9c-1 5.3-4.6 9.8-9.6 11.9s-10.7 1.5-15.2-1.6L256 446.9l-90.3 62.3c-4.5 3.1-10.2 3.7-15.2 1.6s-8.6-6.6-9.6-11.9L121 391 13.1 371.1c-5.3-1-9.8-4.6-11.9-9.6s-1.5-10.7 1.6-15.2L65.1 256 2.8 165.7c-3.1-4.5-3.7-10.2-1.6-15.2s6.6-8.6 11.9-9.6L121 121 140.9 13.1c1-5.3 4.6-9.8 9.6-11.9s10.7-1.5 15.2 1.6L256 65.1 346.3 2.8c4.5-3.1 10.2-3.7 15.2-1.6zM160 256a96 96 0 1 1 192 0 96 96 0 1 1 -192 0zm224 0a128 128 0 1 0 -256 0 128 128 0 1 0 256 0z"></path></svg>
            </button>
            <button id="btn-search" aria-label="search-button">
                <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 512 512"><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352a144 144 0 1 0 0-288 144 144 0 1 0 0 288z"></path></svg>
            </button>
            <button id="btn-nav" aria-pressed="false" aria-label="menu-button">
                <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"></path></svg>
            </button>
        </h1>
        <a href="/" class="site-avatar" aria-label="site-avatar">
            <img src="/assets/img/profile.webp" loading="lazy" alt="homepage" aria-label="homepage-button">
        </a>
    </div>
    <div class="side-info">
        <nav id="navigation">
    
    
    

    

        
    

        
    

        
    

        
    

        
    

        
    

        
    

        
    

        
    
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            

    
    
    

    <ul class="nav-list">
<li id="nav-first" aria-label="Database">
            <div class="nav-item">
                <a href="/Database/" class="nav-list-link nav-lh">
                    <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M181.3 32.4c17.4 2.9 29.2 19.4 26.3 36.8L197.8 128h95.1l11.5-69.3c2.9-17.4 19.4-29.2 36.8-26.3s29.2 19.4 26.3 36.8L357.8 128H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H347.1L325.8 320H384c17.7 0 32 14.3 32 32s-14.3 32-32 32H315.1l-11.5 69.3c-2.9 17.4-19.4 29.2-36.8 26.3s-29.2-19.4-26.3-36.8l9.8-58.7H155.1l-11.5 69.3c-2.9 17.4-19.4 29.2-36.8 26.3s-29.2-19.4-26.3-36.8L90.2 384H32c-17.7 0-32-14.3-32-32s14.3-32 32-32h68.9l21.3-128H64c-17.7 0-32-14.3-32-32s14.3-32 32-32h68.9l11.5-69.3c2.9-17.4 19.4-29.2 36.8-26.3zM187.1 192L165.8 320h95.1l21.3-128H187.1z"></path></svg>
                    <span>Database</span>
                </a><button class="nav-list-expander" aria-label="toggle items in Database category" aria-pressed="false">
                    <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M201.4 342.6c12.5 12.5 32.8 12.5 45.3 0l160-160c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L224 274.7 86.6 137.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3l160 160z"></path></svg>
                </button>
</div>
<ul class="nav-list"><li id="nav-second" aria-label="Postgresql">
                    <div class="nav-item">
                        <a href="/Database/Postgresql/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>Postgresql</span>
                        </a>
</div>
</li></ul>
</li>
<li id="nav-first" aria-label="Etc">
            <div class="nav-item">
                <a href="/Etc/" class="nav-list-link nav-lh">
                    <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M181.3 32.4c17.4 2.9 29.2 19.4 26.3 36.8L197.8 128h95.1l11.5-69.3c2.9-17.4 19.4-29.2 36.8-26.3s29.2 19.4 26.3 36.8L357.8 128H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H347.1L325.8 320H384c17.7 0 32 14.3 32 32s-14.3 32-32 32H315.1l-11.5 69.3c-2.9 17.4-19.4 29.2-36.8 26.3s-29.2-19.4-26.3-36.8l9.8-58.7H155.1l-11.5 69.3c-2.9 17.4-19.4 29.2-36.8 26.3s-29.2-19.4-26.3-36.8L90.2 384H32c-17.7 0-32-14.3-32-32s14.3-32 32-32h68.9l21.3-128H64c-17.7 0-32-14.3-32-32s14.3-32 32-32h68.9l11.5-69.3c2.9-17.4 19.4-29.2 36.8-26.3zM187.1 192L165.8 320h95.1l21.3-128H187.1z"></path></svg>
                    <span>Etc</span>
                </a>
</div>
</li>
<li id="nav-first" aria-label="Git">
            <div class="nav-item">
                <a href="/Git/" class="nav-list-link nav-lh">
                    <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M181.3 32.4c17.4 2.9 29.2 19.4 26.3 36.8L197.8 128h95.1l11.5-69.3c2.9-17.4 19.4-29.2 36.8-26.3s29.2 19.4 26.3 36.8L357.8 128H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H347.1L325.8 320H384c17.7 0 32 14.3 32 32s-14.3 32-32 32H315.1l-11.5 69.3c-2.9 17.4-19.4 29.2-36.8 26.3s-29.2-19.4-26.3-36.8l9.8-58.7H155.1l-11.5 69.3c-2.9 17.4-19.4 29.2-36.8 26.3s-29.2-19.4-26.3-36.8L90.2 384H32c-17.7 0-32-14.3-32-32s14.3-32 32-32h68.9l21.3-128H64c-17.7 0-32-14.3-32-32s14.3-32 32-32h68.9l11.5-69.3c2.9-17.4 19.4-29.2 36.8-26.3zM187.1 192L165.8 320h95.1l21.3-128H187.1z"></path></svg>
                    <span>Git</span>
                </a>
</div>
</li>
<li id="nav-first" aria-label="Java">
            <div class="nav-item">
                <a href="/Java/" class="nav-list-link nav-lh">
                    <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M181.3 32.4c17.4 2.9 29.2 19.4 26.3 36.8L197.8 128h95.1l11.5-69.3c2.9-17.4 19.4-29.2 36.8-26.3s29.2 19.4 26.3 36.8L357.8 128H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H347.1L325.8 320H384c17.7 0 32 14.3 32 32s-14.3 32-32 32H315.1l-11.5 69.3c-2.9 17.4-19.4 29.2-36.8 26.3s-29.2-19.4-26.3-36.8l9.8-58.7H155.1l-11.5 69.3c-2.9 17.4-19.4 29.2-36.8 26.3s-29.2-19.4-26.3-36.8L90.2 384H32c-17.7 0-32-14.3-32-32s14.3-32 32-32h68.9l21.3-128H64c-17.7 0-32-14.3-32-32s14.3-32 32-32h68.9l11.5-69.3c2.9-17.4 19.4-29.2 36.8-26.3zM187.1 192L165.8 320h95.1l21.3-128H187.1z"></path></svg>
                    <span>Java</span>
                </a><button class="nav-list-expander" aria-label="toggle items in Java category" aria-pressed="false">
                    <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M201.4 342.6c12.5 12.5 32.8 12.5 45.3 0l160-160c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L224 274.7 86.6 137.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3l160 160z"></path></svg>
                </button>
</div>
<ul class="nav-list"><li id="nav-second" aria-label="Live-Study">
                    <div class="nav-item">
                        <a href="/Java/Live-Study/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>Live-Study</span>
                        </a>
</div>
</li></ul>
</li>
<li id="nav-first" aria-label="Sap">
            <div class="nav-item">
                <a href="/Sap/" class="nav-list-link nav-lh">
                    <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M181.3 32.4c17.4 2.9 29.2 19.4 26.3 36.8L197.8 128h95.1l11.5-69.3c2.9-17.4 19.4-29.2 36.8-26.3s29.2 19.4 26.3 36.8L357.8 128H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H347.1L325.8 320H384c17.7 0 32 14.3 32 32s-14.3 32-32 32H315.1l-11.5 69.3c-2.9 17.4-19.4 29.2-36.8 26.3s-29.2-19.4-26.3-36.8l9.8-58.7H155.1l-11.5 69.3c-2.9 17.4-19.4 29.2-36.8 26.3s-29.2-19.4-26.3-36.8L90.2 384H32c-17.7 0-32-14.3-32-32s14.3-32 32-32h68.9l21.3-128H64c-17.7 0-32-14.3-32-32s14.3-32 32-32h68.9l11.5-69.3c2.9-17.4 19.4-29.2 36.8-26.3zM187.1 192L165.8 320h95.1l21.3-128H187.1z"></path></svg>
                    <span>Sap</span>
                </a>
</div>
</li>
<li id="nav-first" aria-label="Spring">
            <div class="nav-item">
                <a href="/Spring/" class="nav-list-link nav-lh">
                    <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M181.3 32.4c17.4 2.9 29.2 19.4 26.3 36.8L197.8 128h95.1l11.5-69.3c2.9-17.4 19.4-29.2 36.8-26.3s29.2 19.4 26.3 36.8L357.8 128H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H347.1L325.8 320H384c17.7 0 32 14.3 32 32s-14.3 32-32 32H315.1l-11.5 69.3c-2.9 17.4-19.4 29.2-36.8 26.3s-29.2-19.4-26.3-36.8l9.8-58.7H155.1l-11.5 69.3c-2.9 17.4-19.4 29.2-36.8 26.3s-29.2-19.4-26.3-36.8L90.2 384H32c-17.7 0-32-14.3-32-32s14.3-32 32-32h68.9l21.3-128H64c-17.7 0-32-14.3-32-32s14.3-32 32-32h68.9l11.5-69.3c2.9-17.4 19.4-29.2 36.8-26.3zM187.1 192L165.8 320h95.1l21.3-128H187.1z"></path></svg>
                    <span>Spring</span>
                </a>
</div>
</li>
<li id="nav-first" aria-label="Home">
            <div class="nav-item">
                <a href="/" class="nav-list-link nav-lh">
                    <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M181.3 32.4c17.4 2.9 29.2 19.4 26.3 36.8L197.8 128h95.1l11.5-69.3c2.9-17.4 19.4-29.2 36.8-26.3s29.2 19.4 26.3 36.8L357.8 128H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H347.1L325.8 320H384c17.7 0 32 14.3 32 32s-14.3 32-32 32H315.1l-11.5 69.3c-2.9 17.4-19.4 29.2-36.8 26.3s-29.2-19.4-26.3-36.8l9.8-58.7H155.1l-11.5 69.3c-2.9 17.4-19.4 29.2-36.8 26.3s-29.2-19.4-26.3-36.8L90.2 384H32c-17.7 0-32-14.3-32-32s14.3-32 32-32h68.9l21.3-128H64c-17.7 0-32-14.3-32-32s14.3-32 32-32h68.9l11.5-69.3c2.9-17.4 19.4-29.2 36.8-26.3zM187.1 192L165.8 320h95.1l21.3-128H187.1z"></path></svg>
                    <span>Home</span>
                </a>
</div>
</li>
</ul>
</nav>
        <div id="contact">
            <hr>
            <h3>Contact</h3>
            <ul class="contact-list">
                
                    <li><a aria-label="My Github" href="https://github.com/dmstjd1024">
                        <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 496 512"><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3 .3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5 .3-6.2 2.3zm44.2-1.7c-2.9 .7-4.9 2.6-4.6 4.9 .3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3 .7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3 .3 2.9 2.3 3.9 1.6 1 3.6 .7 4.3-.7 .7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3 .7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3 .7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"></path></svg>
                    </a></li>
                
                
                    <li><a aria-label="My Email" href="mailto:dmstjd1024@naver.com">
                        <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 512 512"><path d="M48 64C21.5 64 0 85.5 0 112c0 15.1 7.1 29.3 19.2 38.4L236.8 313.6c11.4 8.5 27 8.5 38.4 0L492.8 150.4c12.1-9.1 19.2-23.3 19.2-38.4c0-26.5-21.5-48-48-48H48zM0 176V384c0 35.3 28.7 64 64 64H448c35.3 0 64-28.7 64-64V176L294.4 339.2c-22.8 17.1-54 17.1-76.8 0L0 176z"></path></svg>
                    </a></li>
                
                
                
                
                
            </ul>
            <hr>
            <span>
                Copyright © 2024 | <a href="https://github.com/byanko55/jekyll-theme-satellite">Yankos</a>
            </span>
        </div>
    </div>
</div>
<div class="sidebar sidebar-right">
    <div class="tools">
        <button id="btn-brightness" aria-label="brightness-button">
            <svg class="ico-dark" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 384 512"><path d="M223.5 32C100 32 0 132.3 0 256S100 480 223.5 480c60.6 0 115.5-24.2 155.8-63.4c5-4.9 6.3-12.5 3.1-18.7s-10.1-9.7-17-8.5c-9.8 1.7-19.8 2.6-30.1 2.6c-96.9 0-175.5-78.8-175.5-176c0-65.8 36-123.1 89.3-153.3c6.1-3.5 9.2-10.5 7.7-17.3s-7.3-11.9-14.3-12.5c-6.3-.5-12.6-.8-19-.8z"></path></svg>
            <svg class="ico-light" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 512 512"><path d="M361.5 1.2c5 2.1 8.6 6.6 9.6 11.9L391 121l107.9 19.8c5.3 1 9.8 4.6 11.9 9.6s1.5 10.7-1.6 15.2L446.9 256l62.3 90.3c3.1 4.5 3.7 10.2 1.6 15.2s-6.6 8.6-11.9 9.6L391 391 371.1 498.9c-1 5.3-4.6 9.8-9.6 11.9s-10.7 1.5-15.2-1.6L256 446.9l-90.3 62.3c-4.5 3.1-10.2 3.7-15.2 1.6s-8.6-6.6-9.6-11.9L121 391 13.1 371.1c-5.3-1-9.8-4.6-11.9-9.6s-1.5-10.7 1.6-15.2L65.1 256 2.8 165.7c-3.1-4.5-3.7-10.2-1.6-15.2s6.6-8.6 11.9-9.6L121 121 140.9 13.1c1-5.3 4.6-9.8 9.6-11.9s10.7-1.5 15.2 1.6L256 65.1 346.3 2.8c4.5-3.1 10.2-3.7 15.2-1.6zM160 256a96 96 0 1 1 192 0 96 96 0 1 1 -192 0zm224 0a128 128 0 1 0 -256 0 128 128 0 1 0 256 0z"></path></svg>
        </button>
        <button id="btn-search" aria-label="search-button">
            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 512 512"><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352a144 144 0 1 0 0-288 144 144 0 1 0 0 288z"></path></svg>
        </button>
    </div>
</div>
        <div id="post">
            <div class="inner-header">
                <span class="dot" style="background-color: #F86158;"></span>
                <span class="dot" style="background-color: #FBBF2D;"></span>
                <span class="dot" style="background-color: #2ACB45;"></span>
            </div>
            <div class="inner-content">
                <div class="category-tree">
<svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 576 512"><path d="M575.8 255.5c0 18-15 32.1-32 32.1h-32l.7 160.2c0 2.7-.2 5.4-.5 8.1V472c0 22.1-17.9 40-40 40H456c-1.1 0-2.2 0-3.3-.1c-1.4 .1-2.8 .1-4.2 .1H416 392c-22.1 0-40-17.9-40-40V448 384c0-17.7-14.3-32-32-32H256c-17.7 0-32 14.3-32 32v64 24c0 22.1-17.9 40-40 40H160 128.1c-1.5 0-3-.1-4.5-.2c-1.2 .1-2.4 .2-3.6 .2H104c-22.1 0-40-17.9-40-40V360c0-.9 0-1.9 .1-2.8V287.6H32c-18 0-32-14-32-32.1c0-9 3-17 10-24L266.4 8c7-7 15-8 22-8s15 2 21 7L564.8 231.5c8 7 12 15 11 24z"></path></svg>
    <p>
                <a href="/">Home</a>
                &gt;
            </p>
</div>
                
                    <div id="loading">
    <div class="loading_box">
        <img src="/assets/img/loading.webp" loading="lazy">
        <p>Now Loading ...</p>
    </div>
</div>
                    <h1 class="category-header">
    
        All Posts
    
</h1>
<div id="category-list">
    <ul class="paginated-list" data-current-page="1" aria-live="polite">
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Java/Live-Study/2023-01-06-live-study2.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/java_thumbnail.png') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Java/Live-Study/2023-01-06-live-study2.html"><h1 class="title_post">primitive 타입, 변수, 배열</h1></a>
                        <a href="/Java/Live-Study/2023-01-06-live-study2.html" class="txt_post">
                            목적



자바의 프리미티브 타입, 변수 그리고 배열을 사용하는 방법을 익힙니다.

프리미티브라는 한글말만 보고 커피에 타먹는 가루 용어인가 그래서 어원 비슷하게 쓰는가 생각했는데.. 검색해보니 ‘primitive = 기본적인, 원시적인’ 이라는 뜻이라니.. 잠깐 누구도 보지 않았는데 영어가 부족한 내가 부끄러운 순간이었다..

학습할 것



프리미티브 타입 종류와 값의 범위 그리고 기본 값


일단은 정신을 다잡고 primitive 타입을 알아보기 전 일단 변수의 타입에 대해서 알아보자

우리가 사용하는 값은 문자와 숫자로 나뉘어지고 값의 종류에 따라 저장될 공간의 크기와 저장형식을 정의한 것이 자료형이다. 자료형에는 문자형, 정수형, 실수형이 있으며 가장 알맞은 자료형을 변수의 타입으로 선택하면 된다.

자료형은 기본형(프리미티브 타입)과 레퍼런스 타입으로 나뉘는데 이 둘의 비교는 나중에 하고 프리미티브 타입에 대해서 알아보자

프리미타입은 모두 8개의 타입이 있으면 논리형, 문자형, 정수형 실수형으로 구분된다.

프리미티브 타입 종류, 기본값


  
    
      분류
      타입
    
  
  
    
      논리형
      booleantrue와 false 둘 중 하나의 값으로 갖으며 조건식과 논리적 계산에 사용된다.
    
    
      문자형
      char문자를 저장하는 데 사용되며 변수에 하나의 문자만 저장
    
    
      정수형
      byte, short, int, long정수를 저장하는데 사용되며 주로 int가 사용된다. byte는 이진 데이터 다룰 때 사용되며, short는 C언어와 호환을 위해서 추가되었다.
    
    
      실수형
      float, double실수를 저장하는데 사용되며, 주로 double이 사용된다.
    
  


Primitive type 범위


  
    
       
      1byte
      2byte
      4byte
      8byte
    
  
  
    
      논리형
      boolean
       
       
       
    
    
      문자형
       
      char
       
       
    
    
      정수형
      byte
      short
      int
      long
    
    
      실수형
       
       
      float
      double
    
  


값의 범위


  
    
      자료형
      저장 가능한 값의 범위
      bit
      byte
    
  
  
    
      boolean
      false, true
      8
      1
    
    
      char
      ‘\u0000’ ~ ‘\uffff’ (0 ~ 2^16 -1, 0 ~ 65535)
      16
      2
    
    
      byte
      -128 ~ 127 (-2^7 ~ 2^7-1)
      8
      1
    
    
      short
      -32,768 ~ 32,767 (-2^15 ~ 2^15 -1)
      16
      2
    
    
      int
      -2147483648 ~ 2147483647
      32
      4
    
    
      long
      -9223372036854775808 ~ 9223372036854775807
      64
      8
    
    
      float
      3.4E-38(-3.410^38) ~ 3.4E+38(3.410^38)
      32
      4
    
    
      double
      1.79E-308(-1.7910^308) ~ 1.79E+308(1.7910^308)
      64
      8
    
  


프리미티브 타입과 레퍼런스 타입



프리미티브가 기본형이라고 하면 레퍼런스는 그래도 참조형이라고 알고 있다! 여튼 위에 프리미티브 타입에 대해 적었기 때문에 레퍼런스 타입에 대해서 이야기 하자면, 레퍼런스 타입은 어떤 값이 저장되어 있는 주소(memory address)를 값으로 갖는다. 즉 주소를 따라가 적혀있는 값을 사용한다고 생각하면 된다.

참조형 변수를 선언할 때는 변수의 타입을 클래스로 사용해 클래스 이름이 참조변수의 타입이 된다. 즉 새로운 클래스는 새로운 참조형을 추가한다 봐도 된다.

Date today = new Date();


여기서 이 코드의 뜻은 Date 객체를 생성해서 그 주소를 today에 저장이라고 하면 된다.

그리고 참조변수 today를 통해 생성된 객체를 사용할 수 있게 된다.

여기서 프리미티브랑 레퍼런스 차이를 조금 더 추가해서 이야기 하자면, 프리미티브는 date type을 쓰며 레퍼런스의 참조형은 항상 객체의 주소(4byte 정수)를 저장하여 객체의 종류에 의해 구분되므로 type이라는 용어로 사용한다. 허나 타입이 자료형보다 포괄적 의미이므로 굳이 구분할 필요는 없다.

리터럴


리터럴은 일단 상수랑 비교해야 하는데 상수는 프로그래밍에선 값을 한번 저장하면 변경할 수 없는 고유 값이라고 생각하면 된다. ex) final int WIDTH = 20;

그래서 리터럴이 무엇이냐 하면 데이터 그 자체를 말한다. 즉, 위 WIDTH 예시에서 20의 값을 final로 넣은 WIDTH는 상수이고 저 20 이라는 값은 우리가 20이라는 뜻을 세상을 바꾸지 않는 한 변하지 않는 값이 ‘리터럴’이라고 말할 수 있다.ex) 1L (Long타입으로 지정하는 숫자 1)

재미있는건 리터럴의 타입은 저장될 변수의 타입과 일치하는 것이 보통이지만, 타입이 달라도 저장 범위가 넓은 타입에서 좁은 타입으로 저장은 허용된다는 것이다. ex) int i = ‘A’;

변수 선언 및 초기화하는 방법


일단 변수에 대해 뜻을 한번 적어보자면 ‘단 하나의 값을 저장할 수 있는 메모리 공간’ 이라고 정의한다. (그냥 일단 적어봤다)

변수 선언

int age;


이렇게 코드에 적어주면 변수를 선언했다고 말한다.

저기서 int 라고 적어 준 것이 변수 타입이며 저장하고자 하는 값에 맞게 타입을 선택해서 적어주면 된다. 그다음 age 라고 적어 준 것이 변수 이름이며 뜻에 적어놓은 메모리 공간에 붙여준 이름이라고 생각하면 된다. 저 age로 가져오고 저장하는 일을 할 수 있다.

변수의 초기화

변수의 초기화란, ‘변수를 사용하기 전에 처음으로 값을 저장하는 것’ 이며, 뜻 처럼 변수를 선언한 후엔 변수 사용을 할 수 있으나 그 전에 변수를 초기화 해주어야 한다. 메모리는 여러 프로그램에 의해 저장된, ‘알 수없는 값’이 남아 있을 수 있기 떄문이다.

int age = 25;


변수의 종류에 따라 초기화를 생략할 순 있지만, 사용되기 전엔 값을 초기화 시켜주는 것이 좋다.

변수 의 스코프와 라이프타임



스코프

스코프란 뜻은 잘 몰라서 검색해보니 영역이라는 뜻을 가지고 있다. 영역이면 흠.. 백기선님이 말한 변수의 스코프 = 변수의 영역 이면 변수가 쓰이는 공간.. 그러면 한 공간에서 쓰이는 변수의 공간, 영역이면 기본 클래스를 배울 때 class에 선언한 변수는 class 안의 함수에서 쓸 수 있지만, class 내 method 에 선언한 변수는 클래스 밖으로 가져 올 수없다. 이런건가 라고 생각한다.

그리고 이젠 검색해서 찾아보면, 예상이랑 비슷하게 자바 변수가 가질 수 있는 활동 영역이 있고 이걸 스코프라 부른다. 스코프의 종류는 메소드 스코프랑 클래스 스코프로 나뉜다.


  메소드 스코프 : 메소드 내에서 선언해 메소드 내에서만 돌아다니는 영역
  클래스 스코프 : 클래스 내부에 있는 곳을 전부 다 돌아다닐 수 있는 영역


예를 들어 account 클래스가 있고 생성자를 만들어 주려고 한다. (이름을 넣어주는 생성자)

public Class Account{

    String name;

    public Account(String name){
		name = name;
	}
}


이런 식으로 되어 있으면 생성자 내에 있는 name = name; 부분을 보자. 앞의 name은 사실 우리가 원하는 Account 클래스 내의 name에 파라미터로 받아온 값을 클래스 스코프의 name에 넣고 싶은데 저렇게 쓰면 name을 쓰면 파라미터에 파라미터를 넣게 되어버린다. 왜냐면 같은 메소드 스코프 내에서의 name에 name 을 넣겠다는 뜻이기 때문에

우리는 이때 써야할 것은 this가 있다. 이 this라는 것은 자기 자신 객체를 가리키는 키워드로써

this.name = name;


라고 적어주면 우리가 원하는 방식대로 name을 넣을 수 있다.

라이프타임

라이프타임은 내가 구글링이 부족한 지 정보를 잘 알아 낼 수 없어 남들이 올린 과제를 좀 읽어보기로 했다. (센세.. 나 잘하고 있는거 맞죠?) 일단은 여러 글들을 읽어보니 데이터가 살아 있는 시간, 즉 가비지 컬렉터가 돌아가기 전까지의 시간이라고 써져있다. 그리고 라이프 타임이 적용되는 3가지 변수가 있는데 인스턴스 변수, 클래스 변수, 지역변수가 있다.


  
    
      변수
      범위
      생성시기
      종료시기
    
  
  
    
      클래스 변수
      클래스
      클래스 메모리 선언시
      프로그램 종료 시
    
    
      인스턴스 변수
      클래스
      인스턴스 생성
      GB 실행 시
    
    
      지역 변수
      메서드, 생성자, 블럭
      변수 실행
      선언된 범위 넘어갈 때
    
  


타입 변환, 캐스팅 그리고 타입 프로모션


타입변환

‘하나의 타입을 다른 타입으로 바꾸는 것’ 이라고 한다. 자바에서는 논리형 boolean을 제외한 나머지 기본 타입 간 타입변환이 자유롭게 된다.

여기서 하나 주의할 것은 다른 타입끼리의 연산을 수행할려고 하면 피 연산자들을 같은 타입으로 만들어 진행합니다. 그래서 메모리에 할당받은 바이트 크기가 상대적으로 작은 타입에서 큰 타입으로 변경은 생략할 수 있다. 허나 반대인 경우에는 큰 것을 작은 것에 넣다 보니 데이터 손실이 일어난다는 것이다. 따라서 이 때는 자바 컴파일러가 오류를 발생시킨다.

캐스팅

프로그래밍시 가른 타입간의 연산을 수행해야 하는 경우가 있는데, 이때 타입을 일치시켜야 하는데 이거를 캐스팅(형변환)이라고 한다.

방법은 간단히 ‘(타입)피연산자’ 로 정의하며 피 연산자를 타입형으로 바꿨을 땐 값만 변해서 읽을 뿐, 변화는 없다.

그리고 기본형과 참조형은 서로 형변환을 할 수 없다.

타입 프로모션

타입 프로모션.. 이럴수록 영어에 대해 참 막막해질 때가 있다. 처음엔 오 새로운건가 했다가 자동 형변환이라는 해석을 듣고 당황;; 허나 일단은 이걸 적어놓으면 담엔 안헷갈리겠지 하며 적는다.

타입 프로모션은 한국말로 자동 형변환라고 불리며 편의상의 이유로 형변환을 생략하는데 진짜 생략이 아니라 컴파일러가 생략된 형변환을 자동으로 추가해준다.

근데 재밌는건 명시적으로 형변환 해줬을 경우는 의도적인 것을 알고 컴파일러는 에러를 발생시키지 않는다.

char ch = (char)1000;


일단 컴파일러는 자동적으로 더 넓은 타입으로 형변환 해준다.

즉 타입 프로모션의 규칙은 ‘기존의 값을 최대한 보존할 수 있는 타입으로 자동 형변환 해준다.’ 이다.

1차 및 2차 배열 선언하기



배열은 같은 타입의 여러 변수를 하나의 묶음으로 다루는 것 이라고 나온다.

그리고 1차원 선언 방법은

타입[] 변수이름; //배열 선언(배열을 다루기 위한 참조변수 선언)
변수이름 = new 타입[길이]; // 배열을 생성( 실제 저장공간 생성)


2차원 선언 방법은

타입[][] 변수이름; // int[][] score;
타입[] 변수이름[]; // int[] score[];
타입 변수이름[][]; // int score[][];


초기화는 첫번째 [ ] 은 ‘행’ 이고 두번째 [] 은 ‘열’ 이다.

int[][] score = new int[4][2];


타입 추론, var



타입 추론이란, 코드 작성 당시엔 타입이 정해져 있지 않았지만, 컴파일러가 그 타입을 유추하는 것이다.

이는 곧 타입을 명시하지 않아도 되며 가독성을 높일 수 있다.

그리고 var 이거 자바스크립트에서 보던 것인데 java에서 보인다 ( 아직 난 개발자가 되려면 멀었나 보다..)

찾아보니깐 java 10 에서부터 지원하는 변수로 선언할 수 있게 되었다. 그리고 11부터 이를 이용한 람타타입 지원도 생겼다 한다. 그리고 javascript에서 var랑 비슷하면서 다른데 java에서의 var는 종속적인 강타입으로 관리하기 때문이라고 한다. 또한 var는 선언과 동시에 초기화 해줘야 한다. 나는 var 같은 경우는 클래스 타입이 제네릭으로 해서 길거나 값이 복잡해지면 var 쓰고 설명만 잘해놓으면 괜찮게 사용할 수 있다 생각한다. (근데 여긴 내 생각 쓰는데가 아닌데;;) 일단은 백기선님 스터디 들으면서 var에 대한 설명이 나오면 잘 들어봐야겠다.

                        </a>
                        <div class="info-post">
                                <a href="/Java" class="category">Java</a>
                            
                                <span class="date">· 2023-01-06</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Java/Live-Study/2023-01-06-live-study12.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/java_thumbnail.png') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Java/Live-Study/2023-01-06-live-study12.html"><h1 class="title_post">자바의 애노테이션</h1></a>
                        <a href="/Java/Live-Study/2023-01-06-live-study12.html" class="txt_post">
                            목적

자바의 애노테이션에 대해 학습하세요.

학습할 것


  애노테이션 정의하는 방법
  @retention
  @target
  @documented
  애노테이션 프로세서


1. 애노테이션 정의하는 방법


애너테이션이란
프로그램의 소스코드 안에 다른 프로그램의 위한 정보를 미리 약속된 형식으로 포함시킨 것  
프로그래밍 언어에 영향을 미치지 않으면서도 다른 프로그램에게 유용한 정보를 제공하는 장점

작성법
@interface 애너테이션이름 {  
  타입요소 이름();  
 ...}  

@애너테이션이름 -&gt; 애너테이션   
애너테이션이름 -&gt; 애너테이션 타입

애너테이션 내에 선언된 메서드를 애너테이션의 ‘요소’ 라고 하며 요소들을 통해 값을 정의할 수 있다.  
요소들은 반환값이 있고 매개변수가 없는 추상 메서드 형태이며, 상속을 통해 구현하지 않아도 된다.  
다만 요소들의 값은 빠짐없이 지정해줘야 한다. (default를 옆에 붙여주면 기본 값을 가질 수 있다.)
@interface TestInfo{  
 String[] testTools() default {"test1", "test2", ""}  
}  
  
@TestInfo(testTools = {"aaa", "bbb", "ccc"})  
class or method { ~~ } 

만약 이름의 요소가 value 이면 요소이름 생략 가능

java.lang.annotation.Annotation
애너테이션은 상속이 허용되지 않으므로, 명시적으로 Annotation을 조상으로 지정할 수 없다.

2. @retention


애너테이션이 유지되는 기간을 지정하는데 사용한다.


  
    
      유지정책
      의미
       
       
       
    
  
  
    
      SOURCE
      소스파일에만 존재. 클래스파일에는 존재하지 않음
       
       
       
    
    
      CLASS
      클래스파일에 존재. 실행시에 사용불가. 기본값
       
      RUNTIME
      클래스파일에 존재. 실행시에 사용가능.
    
  


컴파일러가 사용하는 애너테이션은 유지 정책이 SOURCE이다.

@Target(ElementType.METHOD)  
@Retention(RetentionPolicy.SOURCE)  
public @interface Override { ...}  


  SOURCE : 컴파일러가 사용하는 애너테이션, 직접작성할 것 아니면 이 유지정책은 필요 없다.
  RUNTIME : , 실행 시 리플랙션을 통해 클래스파일에 저장된 애너테이션 정보를 읽어서 처리할 수 있다.
  CLASS : 클래스 파일에 저장할 수 있게는 하지만 클래스파일이 JVM 로딩될 때는 정보가 무시되어 애너테이션 정보를 얻을 수 없다.


3. @target

애너테이션이 적용가능한 대상을 지정하는데 사용.


  
    
      대상타입
      의미
    
  
  
    
      ANNOTATION_TYPE
      애너테이션
    
    
      CONSTRUCTOR
      생성자
    
    
      FIELD
      필드
    
    
      LOCAL_VARIABLE
      지역변수
    
    
      METHOD
      메서드
    
    
      PACKAGE
      패키지
    
    
      PARAMETER
      매개변수
    
    
      TYPE
      타입
    
    
      TYPE_PARAMETER
      타입 매개변수
    
    
      TYPE_USE
      타입이 사용되는 모든 곳
    
  



  TYPE은 타입을 선언할 때 붙일 수 있고, TYPE_USE는 해당 타입의 변수를 선언할 때 붙일 수 있다.
  FIELD는 기본형에, TYPE_USE는 참조형에 사용된다.


4.  @documented


애너테이션에 대한 정보가 javadoc으로 작성한 문서에 포함되도록 한다. 자바에서 제공하는 기본 애너테이션 중, @Override, @SuppressWarnings를 제외하고는 이 메타 애너테이션이 붙어있다.

@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface FunctionalInterface{}



5. 애노테이션 프로세서


어노테이션을 프로세싱 즉, 내가 보았던 것은 lombok이 대표적이며, 이 외에 이것을 어떻게 작성해야 될 지 모르겠다. 그래서 강의를 들으면서 작성하려고 한다.

Reference

남궁성. Java의 정석

                        </a>
                        <div class="info-post">
                                <a href="/Java" class="category">Java</a>
                            
                                <span class="date">· 2023-01-06</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Java/Live-Study/2023-01-06-live-study.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/java_thumbnail.png') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Java/Live-Study/2023-01-06-live-study.html"><h1 class="title_post">JVM, 자바 코드 실행 과정</h1></a>
                        <a href="/Java/Live-Study/2023-01-06-live-study.html" class="txt_post">
                            목적



자바 소스 파일(.java)을 JVM으로 실행하는 과정 이해하기

남궁성님이 출판하신 JAVA의 정석를 기반으로 작성하려고 한다.

학습할 것

JVM이란 무엇인가


JVM이란 java를 실행하기 위한 가상 머신이다. 여기서 ‘가상머신’ 대신 ‘가상 컴퓨터’라고 부르는게 이해하기 좋다.

자바로 작성된 애플리케이션은 모두 이 가상 컴퓨터에서 실행되기 때문에 Java Application이 실행되기 위해선 반드시 JVM이 필요하다.

일반 Application의 코드는 OS만 거쳐 하드웨어로 전달되는데 Java Application은 JVM을 한 번 더 거치며 실행 될 때 하드웨어에 맞게 컴파일을 진행한다.

그렇다고 JVM 하나로 통합되는게 아니라 각 OS에 맞는 JVM이 실행된다 (ex : Window용 JVM, Macintosh용 JVM, Linux용 JVM )

이래서 자바는 Write once, run anywhere (한번 작성시 어디서든 실행된다.) 라는 장점이 있다.

컴파일 하는 방법


개발 툴을 이용해 .java 파일을 생성하고 build시 java Compiler의 javac라는 명령어를 사용해 .class 파일을 생성합니다. (이 .class는 파일은 아직은 어셈블리어가 아닌 자바 바이트 코드 입니다)
이 파일은 클래스 로더에 의해서 JVM 내로 로드되고 Execution Engine에 의해 기계어로 해석되어 메모리에 배치되게 됩니다. 그리고 Stack Area, Method Heap Area, PC Register Area 에 올라간 파일들은 클래스 메소드 호출이 발생하면 영역의 Method들 정보를 읽어 매개변수, 지역변수 리턴값등이 Stack에 의해 처리되게 됩니다. 그리고 메소드 실행 끝나면 Stack영역에서는 자동으로 제거됩니다. 이후 Garbage Collector가 실행되어 메모리를 정리해주게 됩니다.

바이트코드란 무엇인가


자바의 바이트 코드란 JVM이 이해할 수 있는 언어로 변환된 자바 소스 코드이며, 자바 컴파일러에 의해 변환되는 코드의 명령어 크기가 1바이트라서 자바 바이트 코드라고 불리고 있다.

바이트 코드의 확장자는 .class이며 가상머신만 설치되어 있다면, 어떤 운영체제에서라도 실행될 수 있습니다.

JIT 컴파일러란 무엇이며 어떻게 동작하는지


일단 JIT(Just In Time) 컴파일러란 동적 번역 이라 할 수 있으며 실제로 프로그램을 실행하는 기점에서 기계어로 번역하는 컴파일러이다.

여기서 원래 컴퓨터 프로그램을 만드는 방법은 2가지가 있는데 인터프리트 방식과 컴파일 방식으로 나눌 수 있다.

Interpreter는 실행 중 프로그래밍 언어를 읽어가면서 해당 기능에 대응하는 기계어 코드를 실행한다.

반명 정적 compile은 실행하기 전에 프로그램 코드를 기계어로 번역한다.

여기서 JIT는 두가지를 혼합한 방식이라고 볼 수 있는데 실행시점에서 Interpreter 방식으로 기계어 코드를 생성하면서 그 코드를 ‘캐싱’하여 같은 함수가 여러번 불릴 때 캐싱된 데이터를 사용해 매번 기계어 코드를 생성하는 것을 방지한다.

이래서 한번만 실행되는 코드는 Interpreter 방식이 유리하며 JVM은 메소드가 얼마나 자주 수행되는 지를 체크하여 컴파일을 수행한다.

JVM 구성 요소


JVM은 ClassLoader, Execution Engine, RuntimeData Areas로 구성된다.


  ClassLoader 란


JVM 내로 클래스 파일을 load하고 link를 통해 배치를 수행하는 모듈로 Runtime 시에 동적으로 클래스를 로드한다.

자바는 동적코드, 컴파일 타임이 아니라 런타임에 참조한다.

즉 ,클래스를 처음으로 참조할 때 해당 클래스를 load하고 link한다.


  Execution Engine 란


class loader를 통해 배치된 클래스를 실행시킨다.

클래스 파일(바이트 코드)은 비교적 인간이 보기 쉬운 형태이기 때문에 기계가 실행할 수 있는 형태로 변경시키는데 이때, JIT와 Interpreter 두가지 방식을 사용한다.


  Garbage Collector


동적으로 할당된 메모리 중 사용되지 않은 메모리를 반환하다.

실행 시기는 JVM이 OS에 메모리를 추가적으로


  Runtime Data Area


Excution Engine에게 해석된 프로그램은 Runtime Data Area에 배치되어 돌아간다. 이 때 Runtime Data Area는 3가지 구조를 갖는다.


  Method Area : 클래스영역으로 인터페이스, 클래스, 메소드, 필드 등의 모든 정보가 들어가 있다. 여기는 모든 쓰레드들이 공유하며 new를 통해 동적으로 생성 시 저장되므로 Garbage Collector 의 대상이다.
  Heap : 생성된 인스턴스가 있는 공간으로 Garbage Collector의 대상이며 Heap 정렬을 통해 사용빈도가 높은 인스턴스를 Root Node로 올려서 히트율을 올리는 방식이다. 모든 쓰레드들이 공유한다.
  JVM Stacks : 호출스택이라 불리며 메소드가 실행 시 필요한 공간을 제공, 매개변수나 지역변수 등의 임시데이터를 저장한다. 메소드가 끝나면 메모리공간은 반환된다. 쓰레드마다 1개 씩 갖는다.
  PC Registers : 일종의 스택으로서 Thread 생성될 때의 공간으로 Thread가 어떠한 명령을 실행하게 될지에 대한 부분을 기록한다. Java는 Stacks-Base 방식으로 작동하는데 JVM은 CPU에 직접 Instruction을 수행하지 않고 Stack에서 Operand를 뽑아내 이를 별도의 메모리 공간에 저장하는 방식을 취하는데 이 공간을 PC라고 한다.


JDK와 JRE의 차이



  
    JDK

    자바 개발을 위해 필요한 도구, JRE에서 제공하는 실행 환경뿐만 아니라 자바 개발에 필요한 여러가지 명령어 그리고 컴파일러를 포함했다.
  
  
    JRE

    Java Runtime Environment 의 약자로 자바 실행환경이다. JRE는 자바 프로그램을 동작시킬 때 필요한 라이브러리 파일, java 명령, 및 기타 인프라를 포함하여 컴파일된 Java 프로그램을 실행하는데 필요한 모든 패키지
  


                        </a>
                        <div class="info-post">
                                <a href="/Java" class="category">Java</a>
                            
                                <span class="date">· 2023-01-06</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Java/2023-01-06-jasypt.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/java_thumbnail.png') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Java/2023-01-06-jasypt.html"><h1 class="title_post">Jasypt 암호화</h1></a>
                        <a href="/Java/2023-01-06-jasypt.html" class="txt_post">
                            jasypt 이란

프로젝트를 하면서 이메일 인증이나 DB정보를 저장할 때 값을 노출 시킨 상태에서 github에 올린다면 해킹의 여지가 있기에 jasypt 라이브러리를 사용하자는 이야기가 나왔다.

일단은 암호화에 대한 내용을 찾아봤다.

암호화란 메시지 내용이 불명확하도록 평문을 재구성하는 방식이 메시지의 재구성 방법을 암호화 알고리즘이라 부르고 비밀성을 높이기 위해 key를 사용한다.

암호화와 복호화 과정으로 구성된 시스템을 암호계라 부르며 암호계에는 키 알고리즘, 관용암호계(암호화 복호화에 둘다 사용하는)와 비밀키 공개키를 사용하는 공개키 시스템으로 구분된다고 한다.

여기서 Jasypt은 암호화에 대한 깊은 지식이 없어도 암복호화 프로그램 개발을 지원한다.

jasypt 개요, 설명 사이트

jasypt 사용법


일단 build.gradle의 dependency에 jasypt 등록하시고
    //jasypt
    implementation "com.github.ulisesbocchio:jasypt-spring-boot-starter:3.0.3"



jasypt 암복호화 지원 사이트

링크 들어가셔서 중간에 보시면 암복호화 할 수 있는 기능이 있는데 여기에




  
    Enter plain text to Encrypt = “암호화 할 평문”
  
  
    Select Type of Encryption = “Two Way Encryption(With Secret Text)”
  
  
    Select Key To Be Used While Encryption = ““저희가 사용할 secretKey”
  


입력하시면 Encrypted String에 값 나옵니다. 복사 하신다음



application.yml에 저희 암호화 시킬 property에 모자이크 처리 되어있는 형식안에 적어주시고 돌리시면 배포시 복호화 되어 읽어집니다!

Jasypt Config

또 Config 에서는

@Configuration
public class JasyptConfig {

    @Bean("jasyptStringEncryptor")
    public StringEncryptor stringEncryptor() {

        PooledPBEStringEncryptor encryptor = new PooledPBEStringEncryptor();
        SimpleStringPBEConfig config = new SimpleStringPBEConfig();
        config.setPassword(System.getProperty("jasypt.encryptor.password"));
        config.setAlgorithm("PBEWithMD5AndDES");
        config.setKeyObtentionIterations("1000");
        config.setPoolSize("1");
        config.setProviderName("SunJCE");
        config.setSaltGeneratorClassName("org.jasypt.salt.RandomSaltGenerator");
        config.setIvGeneratorClassName("org.jasypt.iv.NoIvGenerator");
        config.setStringOutputType("base64");
        encryptor.setConfig(config);
        return encryptor;
    }

}



  
    config.setPassword(System.getProperty(“jasypt.encryptor.password”)); : secretKey 설정
  
  
    PBEWithMD5AndDES : MD5와 DES를 이용한 패스워드 기반 암호화
  
  
    config.setPoolSize(“1”); : 암호화를 사용할 공간? 이라는데 숫자에 따라 암호화 사용 공간을 추가할 수 있다고 하네요 ( 메모리를 많이 잡아먹는다는 얘기가 있습니다.)
  
  
    config.setIvGeneratorClassName(“org.jasypt.iv.NoIvGenerator”); :  암호화 시 초기값을 설정하는 부분이라고 들었는데 현재 org.jasypt.iv.randomivgenerator 방식을 사용하려니깐 String 파일을 bind 할 수 없다고 하네요 정상적으로 실행될 때 수정하겠습니다
  


Tomcat 외부변수 등록


이제 secretKey를 적용하려고 하는데 여러가지 방식이 있다. properties에 넣고 git ignore에 등록하는 방식, secretKey를 또 암호화 시켜 개발자들만 아는 방식 등이 있지만 저희는 Tomcat에 등록하여 다들 개발하기 편하게 작업할려고 합니다.

-Djasypt.encryptor.password="secretKey값" 이라고 커스텀 변수 설정하시고



위쪽 톰캣에 등록하시면 외부변수 읽어서 실행 시 읽게 될겁니다~ (단점은 테스트를 돌릴 때에 테스트에도 설정 변수를 입력해야 사용 가능하네요ㅠ)

잘못된 내용이 있으면 얘기해주세요 ~

                        </a>
                        <div class="info-post">
                                <a href="/Java" class="category">Java</a>
                            
                                <span class="date">· 2023-01-06</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Git/2023-01-06-github-blog-local-batch.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/github_thumbnail.png') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Git/2023-01-06-github-blog-local-batch.html"><h1 class="title_post">깃허브 블로그 로컬로 돌리기</h1></a>
                        <a href="/Git/2023-01-06-github-blog-local-batch.html" class="txt_post">
                            깃허브 블로그 실행 파일

처음엔 남들 github.io에 개발 관련 블로그가 많이 보이길래 저건 어떻게 만들지 하며
  찾아보니깐 깃허브로 무료 호스팅을 제공하는거라 한다.  
  나는 이런 글을 쓰는 것이 좀 어색하지만 차츰 글의 양을 늘려보도록 하겠다.

일단 jekyll 설치, 실행 방식은 구글링을 통해서 쉽게 접할 수 있다.  
  근데 ruby를 켜서 실행할 때 마다 일일히 루비 명령 프롬프트를 켜서 진행을 해야한다.

## 실행 파일 생성

일단 메모장 파일을 생성하고 다음과 같은 코드를 입력한다.

코드
cd C:\Ruby26-x64\bin\setrbvars.cmd
call setrbvars.cmd
cd 클론해온 리포지터리경로\리포지터리 이름
bundle exec jekyll serve


다른 이름으로 저장


이렇게 저장하면 bat 파일이 생성된다.



실행하면 http://localhost:4000 포트에서 돌아가고 있는 것을 확인할 수 있다.

                        </a>
                        <div class="info-post">
                                <a href="/Git" class="category">Git</a>
                            
                                <span class="date">· 2023-01-06</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Git/2023-01-06-git-flow.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/github_thumbnail.png') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Git/2023-01-06-git-flow.html"><h1 class="title_post">Git flow와 Jira 사용 전략</h1></a>
                        <a href="/Git/2023-01-06-git-flow.html" class="txt_post">
                            일단 프로젝트를 진행하면서 저희는 코드 관리는 github를 사용하기로 했고
테스크 툴로는 Jira를 사용하기로 했다. 그리고 협업 전략에서
git flow라는 것을 알게 되었다. 일단 이것들이 먼지 살펴보려고 한다.

git flow란?

프로젝트 브랜치 전략의 개발 모델 또는 방법론

Vincent Driessen 이란 사람은
자기가 만들긴 했지만 무조건 지킬 필요없이 개발환경에 따라 바꿔서 사용하라 한다.

브랜치 종류

master : 배포 브랜치  
develop : 개발 브랜치 -&gt; feature 브랜치를 합치는 브랜치  
feature : 기능 개발 브랜치로 어떤 기능이 완료되면 develp 브랜치에 push한다.  
release : develop이 완성되고 master 넣기전 품질 검사하는 브랜치  
hotfix : 배포했는데 버그가 생기면 긴급 수정하는 브랜치

운영


JIRA 이슈 생성 -&gt; intellij jira 연결 -&gt; plugin 다운(git flow integration) -&gt; git flow init -&gt; feature 생성(이슈 진행) -&gt; commit -&gt; develop 브랜치 pullRequest 전송(완료 리뷰예정) -&gt; 코드리뷰 -&gt; develop에 merge(feature 브랜치 삭제)

운영순서

1) JIRA 이슈 생성



2) Intellij Jira 연결

intellij를 실행하고 Settings -&gt; Tools -&gt; Tasks -&gt; Servers에 가서 Add 버튼 누른 뒤 JIRA 선택 후 다음과 같은 값을 적어준다.



API Token 같은 경우는 API Token 발급 참고하면 될거같다

3) Git flow integration 설치

plugins 가서 git flow 검색해서 설치하면 된다.(이건 간단하니깐 설명 생략)

4) git flow init



5) feature 생성(이슈 진행)

Jira랑 연결이 되면 Default task라는 부분이 생성되고 클릭시



이라고 생성되는데 여기서 하얀줄 같은 경우가 Jira에서 할당받은 이슈가 생성되고 클릭시 그에 맞게



위의 그림처럼 자동으로 만들어준다.  
(모든 사진에 흰색으로 지운거는 호옥시나 문제될까봐.. )

그리고 생성되면 git flow가 진행된다!

6) commit
이슈에 맞는 코드를 입력하고 commit을 진행한다.

일단

다음 포스트에서 배포하는방법을 작성하겠다!

                        </a>
                        <div class="info-post">
                                <a href="/Git" class="category">Git</a>
                            
                                <span class="date">· 2023-01-06</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Etc/2023-01-06-SSR,%20SSG.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/ect_thumbnail.jpg') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Etc/2023-01-06-SSR,%20SSG.html"><h1 class="title_post">SSR, SSG</h1></a>
                        <a href="/Etc/2023-01-06-SSR,%20SSG.html" class="txt_post">
                            SSR, SSG, jamstack

SSR
Server Side Rendering으로 서버에서 HTML 구조로 응답하는 방식

CSR
Client Side Rendering (ex Angular, React, Vue) javascript로 동적 페이지를 출력

SPA
Single Page Application으로 한 페이지 내에서 모든 동작을 수행 ( CSR과는 다른 개념)

SEO (Search Engine Optimization)
검색 페이지 적합하게 만들어진 페이지, 크롤링을 통해 구조, 컨텐츠 파악해 목차와 색인을 만드어 사용자 검색의 결과물을 나타낸다.

Next.js, Nuxt.js
Next.js는 React, Nuxt.js는 Vue에 각각 두개의 장점을 가져오는 ssr로 페이지를 제공하는 기능들을 추가 즉( CSR을 통해 비 동기인 방식으로 요청했을 때, SSR의 장점인 html 구조로 응답하는 방식

Vue를 통해 만든 프로젝트를 요청했을 때, 처음에 div만 들어있는 페이지를 호출하고, 브라우저의 요청이 실행되었을 때, 링크된 자바스크립트 파일을 다운로드 뒤 데이터를 요청해서 서버에 받아온 데이터들을 클라이언트에서 모양을 생성해 출력한다. 이때 요청이나 로직이 많은 경우라면 시작 시에 딜레이가 발생한다.

허나 Next.js나 Nuxt.js를 사용하면 기존에 노출시키고 싶은 페이지와 데이터를 mounted()를 통해 먼저 렌더링 한 후, fetch 코드를 사용하여 변화되는 데이터를 API 서버에 요청해 받아오는 것이다. node js가 깔린 서버에서 프로젝트를 어플리케이션으로 실행해 프론트를 배포한다. 즉, 페이지에서 접속시 바로 출력할 내용을 서버에 미리 렌더링 해 출력한다.

또한 mounted를 통해 먼저 렌더링했을 경우 SEO에 잡힐 수 있기 때문에 검색결과에 노출 비중이 높다.

SSG
Static Site Generator, 정적 사이트 생성기, -&gt; 렌더링을 다 마친 정적 파일들을 배포,
정적인 사이트를 만들 때엔 json, yaml, xml등의 view 파일에 저장하고 build 시 html 태그 구조에 맞게 수정한 html 파일을 서버에 저장시켜 놓는다. (Next, Hugo, Gatsby)

Jam Stack

Javascript API Markup + Stack 으로 웹서비스 만드는 설계 방식, 
pre-landering, decoupling

자바 스크립트를 사용한 Jam으로 페이지를 Pre 렌더링 후 외부 API 서비스로 아웃소싱해서 설계 분리(decoupling) 
이렇게 만든 정적 페이지를 CDN으로 배포하는 방식이다. 이걸 통해 비용절감, 보안강화, 사이트 확장에 용이하다.

                        </a>
                        <div class="info-post">
                                <a href="/Etc" class="category">Etc</a>
                            
                                <span class="date">· 2023-01-06</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Database/Postgresql/2023-01-06-postgresql.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/postgresql_thumbnail.png') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Database/Postgresql/2023-01-06-postgresql.html"><h1 class="title_post">PostgreSQL이란</h1></a>
                        <a href="/Database/Postgresql/2023-01-06-postgresql.html" class="txt_post">
                            PostgreSQL

오픈 소스 객체 관계형 데이터베이스  
새로운 하나의 프로그래밍처럼 구현하는 기능을 제공한다.

구조

클라이언트 / 서버 모델 사용

기능

트랜잭션과 ACID(Atomicity, Consistency, Isolation, Durability)를 지원
또한 주요 기능들을 많이 가지고 있다고 한다.

Nested transactions (savepoints)    
Point in time recovery  
Online/hot backups, Parallel restore  
Rules system (query rewrite system)  
B-tree, R-tree, hash, GiST method indexes  
Multi-Version Concurrency Control (MVCC)  
Tablespaces  
Procedural Language  
Information Schema  
I18N, L10N  
Database &amp; Column level collation  
Array, XML, UUID type  
Auto-increment (sequences),  
Asynchronous replication  
LIMIT/OFFSET  
Full text search  
SSL, IPv6  
Key/Value storage  
Table inheritance

등등 여러 기능들을 제공한다고 하는데 여기서 Auto-increment나 Limit 등등 빼고는 잘 접하지 않아서 그런지 이해는 못하겠다. 나중에 PostgreSQL을 좀 더 많이쓰는 일이 생기면 접할 것 같다.

특징


  
    유연한 객체 생성  
단순한 자료 저장소로써의 기능을 넘어 마치 하나의 새로운 프로그래밍 언어처럼 개발자의 창의성에 따라 무한한 기능을 손쉽게 구현할 수 있도록 한다.
  
  
    상속  
java 또는 C++ 프로그래밍 언어와 같이 테이블을 만들어 그 테이블 상속 기능을 이용해 하위 테이블을 만들 수 있다. 테이블에 저장된 자료는 상위 테이블을 조회하면, 해당 테이블의 하위 테이블에 포함된 모든 자료를 조회할 수 있으며, 하위 테이블을 만들 때, 상위 테이블의 칼럼을 그대로 상속 받으면서, 하위 테이블에만 속하는 칼럼을 추가로 만들 수 있다.
  
  
    함수  
때때로, ‘저장 프로시저’라고 불리는 SQL문으로 작성된 함수를 서버환경에서 사용할 수 있다. 비록 다른 언어와는 달리 제어문과 반복문을 사용하지는 못하지만, 다른 언어와 결합시킬 수 있다. 일부 언어에서는 심지어 트리거 내부에서 실행시킬 수 있다.
  




내 생각

일단은 이러한 장점들이 있지만 현재 프로젝트에선 JPA를 활용하여 진행하므로 PostgreSQL의 장점을 활용할 기회가 있을지는 잘 모르겠다. 차후 postgresQL의 특징을 사용하는 경험이나 정보를 듣는다면 추가로 적용하겠다.

                        </a>
                        <div class="info-post">
                                <a href="/Database" class="category">Database</a>
                            
                                <span class="date">· 2023-01-06</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Spring/TICKET-EXPEDITIONARY-FORCE/2023-01-06-TICKET-EXPEDITIONARY-FORCE-start.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/spring_thumbnail.webp') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Spring/TICKET-EXPEDITIONARY-FORCE/2023-01-06-TICKET-EXPEDITIONARY-FORCE-start.html"><h1 class="title_post">티켓 원정대 출발!</h1></a>
                        <a href="/Spring/TICKET-EXPEDITIONARY-FORCE/2023-01-06-TICKET-EXPEDITIONARY-FORCE-start.html" class="txt_post">
                            프로젝트 시작

TDD 책을 정독하고 읽었던 내용들을 사용해보는 프로젝트를 진행해보려고 한다.  
 나는 2,3번 프로젝트를 진행해봤는데 결과는 좋지 않았고 이번에는 결과물을 완성하고 싶은 마음이 크다.



설명

100명에게 Ticket을 배포하는 프로그램을 RESTful방식 개발합니다 *신청시 확률에 따라 티켓을 획득 하거나 꽝이 됩니다

  티켓:100매
  로그인도 추가하기 (카카오, 네이버)
  공인 IP당 1회 신청가능
  30%확률로티켓획득가능
  WAS는 2대 이상 이용한다고 가정




사용 기술


  
    
      기술명
      내용
    
  
  
    
      spring boot
      Spring framework의 다양한 설정을 최소화
    
    
      thymeleaf
      스프링에서 미는 Java XML / XHTML / HTML5 템플릿 엔진
    
    
      lombok
      getter, setter, 등의 기본 메서드 코드 간략화
    
    
      spring boot test
      spring 통합테스트 진행으로 api 테스트 사용
    
    
      h2 database
      RDBMS, 메모리에 데이터 저장 용도(추후 database 추가)
    
    
      spring boot security
      spring 기반 Application 보안, 인증 담당 framework
    
    
      swagger
      api 문서화 활용
    
    
      bootstrap
      웹사이트 꾸며주는 HTML, CSS, JS 프레임워크
    
    
      git
      버전관리 툴로 github를 통해 개발 진행
    
  




파트


  템플릿 설정
  티켓
  회원 관리(내 파트)
  로그인


개발 방법  
 애자일 방법론으로 서로 스터디를 통한 프로젝트이기에 짧은 반복을 진행할 것이며  
 배달의 민족에서 사용하는 git flow를 사용해 기능마다 merge시키는 방식을 진행할 것입니다.



처음 내가 해야 할 일
Account Entity에서 내가 생각하는 column명을 Template 설정 파트 담당에게 넘길 것이다.


                        </a>
                        <div class="info-post">
                                <a href="/Spring" class="category">Spring</a>
                            
                                <span class="date">· 2023-01-06</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Spring/TICKET-EXPEDITIONARY-FORCE/2023-01-06-SETTING-ACCOUNT-ENTITY.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/spring_thumbnail.webp') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Spring/TICKET-EXPEDITIONARY-FORCE/2023-01-06-SETTING-ACCOUNT-ENTITY.html"><h1 class="title_post">엔티티 설정</h1></a>
                        <a href="/Spring/TICKET-EXPEDITIONARY-FORCE/2023-01-06-SETTING-ACCOUNT-ENTITY.html" class="txt_post">
                            고민


과연 Account 객체를 생성할 때 필요한 column명을 찾아서 적어봤다.



Account

@Getter
@Builder
@Entity
@NoArgsConstructor
@AllArgsConstructor
public class Account {

    @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name="account_id")
    private Long id;

    @NotEmpty
    @Column(unique = true)
    private String publicIp;

    @Column(unique = true)
    private String loginId;

    @NotEmpty
    private String password;

    private String name;

    @Column(unique = true)
    private String nickname;

    @Column(unique = true)
    private String email;

    @Lob
    private String profileImage;

    private LocalDateTime createDate;

    private LocalDateTime modifyDate;

    @Enumerated(EnumType.STRING)
    private Role role;

}


##주요 어노테이션

일단 DB Diagram을 그려야 하는데 아직 모여서 정확하게 테이블 컬럼들을 정리하지 않아
 내가 블로그에서 봤던 기준으로 간단하게 Account를 정의해봤다.

@GeneratedValue(strategy = GenerationType.IDENTITY)

전적으로 db에게 기본키 생성을 위임한다. (아직 db쪽이 약해서 설명을 자세하게 쓰지 못했는데
좀더 알아보고 수정해서 적어봐야겠다.)

@Lob

Lob은 Large Obejct란 뜻으로 프로필사진같은 경우 데이터가 크기 때문에 지정하는 것도 있고
  데이터를 안정성 때문이다. -&gt; 만약 이미지 경로로 지정해놨을 때 실수로 이미지 경로의 파일들이
  사라지는 경우 이미지파일을 찾을 수 없게되기 때문이다.

@Enumerated(EnumType.String)

Entity에선 enum을 db에 저장할 땐 default로 EnumType.ORIGINAL로 지정되있다. 이때 ORIGINAL로 저장하면
DB에 순서 enum의 순서를 정수로 저장하는데 이는 나중에 db를 볼때 1, 2, 3 등등으로 저장되기에
식별하기가 어려워 enum의 이름을 직접 저장하도록 string을 사용했다.



내 생각

일단 기본적으로 내가 아는 것들에 대해서 써놓았고 팀원들과 코드리뷰를 통해 Ticket이나 다른 테이블들의
컬럼과 연관관계를 짓는 작업을 진행해야겠다.

                        </a>
                        <div class="info-post">
                                <a href="/Spring" class="category">Spring</a>
                            
                                <span class="date">· 2023-01-06</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Spring/2023-01-06-Hateoas.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/spring_thumbnail.webp') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Spring/2023-01-06-Hateoas.html"><h1 class="title_post">내가 적어보는 Hateoas 정리</h1></a>
                        <a href="/Spring/2023-01-06-Hateoas.html" class="txt_post">
                            Hateoas



티켓 프로젝트를 진행하면서 rest(ful?) api 문서화를 만드는 중, 우리는 hateoas를 당장 써서 만들어야 할지 아닐지 고민되었다. 그래서 일단 자료조사를 위해서 hateoas에 대해 알아보려고 한다.

Hateoas 란?



Wikipedia에서 ‘hateoas’란 Hypermedia As The Engine of Applicaton state 라는 뜻으로 다른 어플리케이션 아키텍쳐랑 구별되는 REST 어플리케이션 구조 의 요소라고 정의해놨다. hateoas를 사용함으로써 클라이언트는 하이퍼미디어를 통한 다이나믹한 정보를 어플리케이션 서버에 제공하는 네트워크 어플리케이션과 상호작용할 수 있다. 이 제한은 클라이언트와 서버를 분리해주는 것을 도와준다고 말한다.

즉, 쉽게 말해 프론트 부분에서 가공해서 클라이언트한테 지원해줄 필요 없이 hateoas를 사용해 동적으로 상태나 전이를 전달해준다. 이는 더 높은 수준과 rest에 걸맞는 rest(ful?) api를 만들 수 있게 해준다.

Hateoas 사용법



hateos 설정

일단은 의존성을 통해

    implementation 'org.springframework.boot:spring-boot-starter-hateoas'


라이브러리를 설정만 해주면 끝난다.

hateoas 사용

예를 들어 내가 보내주고 싶은 ‘AccountDto’가 있다면

AccountCotroller.java

AccountDto accountDto = new AccountDto(); // 예시론 빈 객체 생성인데 보내고 싶은 Dto 부분이라고 생각하면 된다
EntityModel&lt;AccountDto&gt; entityModel = EntityModel.of(accountDto);

entityModel.add(linkTo(AccountController.class).slash(accountDto.getId()).withSelfRel() );
// 자신 컨트롤러와 매핑된 URL, 주어진 accountDto의 Id 값을 가져와 withSelfRel()을 사용해 해당 url이 자기 참조라는 것을 추가해 entityModel에 넣어준다.

entityModel.add(linkTo(AccountController.class).slash(accountDto.getId()).withSelfRel("my") );
// 자신 컨트롤러와 매핑된 URL, 주어진 accountDto의 Id 값을 가져와 withSelfRel()을 사용해 my라는 relation을 만들어준다.

entityModel.add(linkTo(AccountController.class).slash(accountDto.getId()).withSelfRel() );
// 자신 컨트롤러와 매핑된 URL, 주어진 accountDto의 Id 값을 가져와 withRel()을 사용해 self라는 relation을 만들어준다.

entityModel.add(Link.of("/docs/index.html#resources-account-get").withRel("profile"));
// 이 부분은 내가 임의로 지정한 부분에 relation을 만들어 추가해준다 (여기서는 restdocs에 지정한 부분으로 이동하게).




여기서 linkTo()와 Link.of() 두가지가 나오는데, linkTo()는 내가 원하는 Object를 찾아 linkTo()가 제공하는 다양한 기능을 사용해 내가 리턴해줄 url에 추가로 넣어주는 것이고, Link.of()는 new Link로 임의로 url을 만들어 준 뒤 relation을 추가해준다 생각하면 된다.

리턴 방식은

return ResponseEntity.ok(entityModel);


나 다른 ResponseEntity의 함수나 객체를 생성해 던져주면

원래 리턴 값 ResponseEntity.ok(accountDto);

{
 "id":1,
 "name":"test",
 "email":"test@email.com",
 "role":"ROLE_USER"
}


Hateoas 적용

{
- "id":1,
- "name":"test",
- "email":"test@email.com",
- "role":"ROLE_USER",
- "_links":{
    "self":{
   	 	"href":"http://localhost:8080/api/account/1"
	},
	"profile":{
        "href":"/docs/index.html#resources-account-get"
    }
}

}




이런 식으로 application/hal+json 으로 된 JSON을 리턴한다.

적용 후기


일단은 매우 기초적으로 hateoas를 적용해서 던져보았는데 좀 더 찾아보면 EntityModel 안에 다양한 기능들이 있고 이걸 사용하면 self, profile 말고 더 많은 url들을 이용해 다양하게 처리할 수 있다. (ex PageResourceAssembler 를 이용해 동적 페이징도 처리 가능하다.)

이렇게 전송되어 보내면 요청에 대한 URL을 던질 때 동적으로 처리할 수 있어 이후에 URL 정보가 변경되더라도 클라는 일일히 가서 수정할 필요가 없다. (허나 예제에선 그 장점이 두각되진 않았다ㅠ)

hateoas를 dto 안에 넣을 수 있을 까

여기서 우리는 ApiResponseDto 안의 data 라는 제네릭 타입에 집어넣은 상태에서 application/hal+json을 유지할 수 있냐이다.

그리고 여러 구글링을 찾아본 결과

hateoas 랑 Dto 관계?

이 스택오버플로우의 이야기 중 “hateoas는 dto을 대체하지 않는다. dto 위에 구축된다. 따라서 Dto 클래스를 확장해야 한다.”

이걸 읽고 만약 hateoas를 적용해야 한다면 ApiResponseDto에 hateoas가 지원하는 Model을 상속받아 구성해야 하는데, 어떻게 뜯어서 진행해야 할지는 팀원들과 이야기 한 다음에 결정해야 할 것 같다.

                        </a>
                        <div class="info-post">
                                <a href="/Spring" class="category">Spring</a>
                            
                                <span class="date">· 2023-01-06</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Spring/2023-01-06-DTO.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/spring_thumbnail.webp') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Spring/2023-01-06-DTO.html"><h1 class="title_post">DTO 처리방법</h1></a>
                        <a href="/Spring/2023-01-06-DTO.html" class="txt_post">
                            티켓 프로젝트를 진행하다가 다들 DTO에 대한 처리방식이 있었는데 나도 하나 적고 싶어서 DTO에 대한 내용을 찾다가

DTO에 관한 고찰
이분에 대한 내용 글이 재미있어서 읽고 블로그에 정리하고 싶어졌다.

DTO 란?

Data Transfer Object 로 계층간의 데이터를 교환하기 위한 자바 Beans를  말한다고 한다.

속성과 속성에 접근하기 위해 getter와 setter를 사용한다고 말한다.

VO 란?
값 자체를 표현하는 객체( 특정한 값을 나타내는 객체 )
서로 다른 이름을 가진 VO 인스턴스가 모든 속성 값이 같다면 같은 객체이다. (equals(), hashCode()을 Overriding 해줘야 한다.)
객체의 불변성을 보존한다.
로직을 포함할 수 있다.

DTO == VO ?
DTO를 VO 처럼 불변 객체로 사용하면?
 -&gt; DTO가 전송하고자 하는 데이터가 전송 과정 중에 변조되지 않음을 보장한다.

Entity
실제 DB의 테이블과 매핑되는 클래스  
Id로 구분  
로직을 포함할 수 있다.

Entity를 DTO로 사용하면 안되나?
사용할 순 있지만, View에서 표현하는 속성 값들이 요청에 따라 계속 달라질 수 있는데 그때마다
Entity의 속성 값을 건들면 영속성 모델로 표현한 Entity의 순수성이 모호해져서 Controller에서
쓸 DTO와 Entity 클래스를 분리하는게 좋다.

DTO를 쓰는 이유

테이블과 매핑되는 Entity 클래스가 변경되면 여러 클래스에 영향을 미치기 때문에
MVC의 View와 통신하는 DTO 클래스는 자주 변경되므로 분리한다고 한다.
또한 Entity에서 원하는 데이터만 추려서 View에 전송할 수 있다.

DTO를 어떻게 사용할 것인가


  어디부터 어디까지 DTO를 사용할 것인가


Data Transfer Object는 계층 간 이동을 위해 만들어진 객체이므로 직접적인 Entity를 사용하자는
Repository 전까지 즉, Clinet - Controller - Service 이 세가지 계층을 오고 갈 때 사용하는 것이 맞다
생각한다.


  Entity 와 DTO 간의 변화는 어떻게 진행할 것인가


Entity와 DTO 간의 변화는 생성 될 인스턴스 변수에 직접 값을 넣어주는게 맞다 생각하고 이때 ModelMapper 사용으로 유지보수에 힘을 실어준다.


  어떻게 만들 것인가


원래는 그냥 그에 맞게 함수 만들어 줄까 생각 했었는데, 링크 건 블로그 내용에 Entity에서 DTO는 static of(엔티티) 형식에 ModelMapper를 사용하는 것을 보고 저렇게 적으면 나중에 변화에 유연한 대처가 가능하다 생각해서 저렇게 적고 DTO에서 Entity는 builder를 사용한다고 말하는데 나는 ModelMapper를 활용해
toEntity(DTO) 안에서 반대로 ModelMapper.map(DTO, Entity.class) 형식을 사용하면 어떤가 생각한다.

또한 링크를 걸은 블로그 필자는 class 안에 static class로 만들어 사용한다고 하는데 나는 작업하면서 한 클래스 안에 inner class가 많으면 찾기 어려운 것과 보는 것에서 불편하다 느껴 유연하게 사용하는게 낫다 생각한다.

거의 블로그 내용을 붙인 내용도 많지만 나에 대한 생각도 여럿 적어보니 좀 뿌듯하기도 하다.

                        </a>
                        <div class="info-post">
                                <a href="/Spring" class="category">Spring</a>
                            
                                <span class="date">· 2023-01-06</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Sap/sapui5/2023-01-06-sapui5.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/sap_thumbnail.png') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Sap/sapui5/2023-01-06-sapui5.html"><h1 class="title_post">SAP UI5 란</h1></a>
                        <a href="/Sap/sapui5/2023-01-06-sapui5.html" class="txt_post">
                            SAP UI5

SAP UI5 란



  
    HTML5, CSS, JavaScript로 구성된 클라이언트 UI 기술이다.
  
  
    SAP UI5로 개발된 앱들은 우리가 사용하는 장치의 브라우저 안에서 실행한다.
  
  
    사용자들이 앱을 액세스 할 때, 해당 서버로 애플리케이션을 브라우저에 로드하라는 요청을 전송, View는 SAP UI5에 관련된 라이브러리를 액세스한다. 모델은 또한 인스턴스화되고, 비즈니스데이터는 데이터베이스로부터 가져온다.
  
  
    SAP UI5가 사용되는 환경에 따라, 라이브러리 또는 애플리케이션을 SAP NetWeaver Application Server 또는 SAP Business Technology Platform 등에 저장할 수 있으며, 비즈니스 데이터(예: SAP Gateway)를 통해 OData 모델을 사용하여 액세스할 수 있다.
  
  
    프레임워크의 아티팩트는 라이브러리라는 최상의 구조단위로 되어있으며, 라이브러리는 확장성 개념을 가진 아티팩트이다.  이들은 공통으로 사용되는 기본 라이브러리와 함께 미리 정의된다. 라이브러리는 타입들의 제어, 그리고 웹 어플리케이션에 의해 사용되도록 묶어놓았다. 동시에 미리 정의된 sap.m이라는 라이브러리와 나란히 쓰고 사용하기 쉽게 만들어 첫번째로 커스텀 ui 라이브러리로 취급된다.
  
  
    UI element는 사용자 인터페이스가 기본으로 되어 있으며 속성, 이벤트, 메소드, 관계와 같은 엔티티들을 재사용하며 최고로 중요한 관계는 다른 UI 엘리먼트들을 트리 구조로의 방식으로 생성될 수 있게 집계한다.
  
  
    개발자가 보는 화면의 관점으로부터 제어 요소는 가장 중요한 아티팩트이다. 이것은 사용자 화면에 나타내는 모든 컨트롤을 제어하는 객체이며 이것은 각 트리구조의 루트로 사용될 수  있는 유저인터페이스 요소의 종류이다. 이 방식은, 특히 렌더링을 위한 엔트리 포인트을 제공한다. 이들은 루트로서 사용될 수 없는 트리구조의 비제어 요소들이다. 그러나 단지 몇몇 부분은 종속적으로 사용된다.
  
  
    데이터 타입들은 메타 모델 안의 첫번째 클래스로 정의된 엔티티들이다. 타입 시스템의 확장성과 라이브러리 교차타입을 재사용하도록 허락한다. sap.ui.core 라이브러리는 다른 라이브러리들에 사용될 수 있는 타입으로 미리 정의한다.
  


Bootstrapping

브라우저 실행되자마자 스크립트를 로드함으로 SAP UI5 실행이 자동으로 페이지에 실행한다. 단순한 SAP UI5 기본 설치를 사용하는 경우에 UI를 실행하기에 충분하다. 이외에도 세팅을 통해 너의 어플리케이션 테마나 라이브러리를 설정할 수 있다.
&lt;script id="sap-ui-bootstrap" type="text/javascript"
	src="resources/sap-ui-core.js"
	data-sap-ui-theme="sap_belize" // 기본 테마 설정
	data-sap-ui-libs="sap.m" // 라이브러리 설정 
	data-sap-ui-compatVersion="edge"&gt;
 &lt;/script&gt;


SAP UI5는 여러 부트스트랩을 제공하고 있다.

sap-ui-core.js :  기본 부트스트랩 파일이며,  SAP에서 이 타입을 쓸 것을 추천한다. 이것은 이미 jquery 와 core library의 최소한의 요구를 이미 정의하고 있다. 파일 요구는 XHR 을 다양하게 로드된다.

Content Delivery Network (CDN) : CDN을 이용해서 다양한 라이브러리를 엑세스 할 수 있다.

sap-ui-core-nojQuery.js : SAP 제공 jquery가 아닌 다른 버전의 jquery를 실행할 때 사용한다.

sap/ui/core/library-preload.js :  미리 파싱해놓고 필요할 때 호출한다.

sap-ui-core-lean.js : jquery나 sap ui5 즉시 로드되고 다른 파일은 다이나믹하게 로드된다.

Components

SAPUI5 어플리케이션의 컴포넌트는 독립적이며, 부분 재 사용 가능하다.

SAP UI5는 어플리케이션이 동작하는 곳으로 부터 다른 위치의 컴포넌트 사용할 수 있다.

따라서 컴포넌트는 다른 팀과 협업적으로 사용할 수 있다.

캡슐화 지원으로 어플리케이션 구조와 코드를 더 쉽게 이해할 수 있다.

SAP UI5는 두 가지 컴포넌트 타입을 지원한다.

  
    Faceless components (class: sap.ui.core.Component)
유저 인터페이스를 사용하지 않으며, UI 엘리먼트가 필요하지 않은 곳에서 코딩이 사용된다. faceless 컴포넌트들은 ComponentContainer에 추가할 수 없다.
  
  
    UI components
Component들을 상속받으며 컴포넌트의 기술적인 렌더링을 추가한다. 유저인터페이스의 각각의 설정, 메타데이터에 따라 화면 영역이나 요소들을 나타낸다.
sap.ui.core.UIComponent는 sap.ui.core를 상속받으며 기능요소들을 렌더링한다.
  


컴포넌트는 sap.ui.component란 팩토리를 통해 생성되고 불러온다.컴포넌트들은 에 지정된 디스크립터(manifest.json)를 통해 불러올 수 있다. SAP는 디스크립터를 통해 컴포넌트 파일들을 호출하는 것을 추천한다. 프로세스가 로딩 중에 최적화 되어 퍼포먼스를 증가시키기 때문이다. 디스크립터는 메타데이터 요소들을 포함하며 또한 의존성과 설정에 대한 구성을 표현한다. 컴포넌트의 필수와 옵션 리소스는 구성요소의 네임스페이스에 조직적이여야 된다.

디스크립터를 로딩한 후에 컴포넌트 팩토리는 의존된 라이브러리나 컴포넌트들을 평행화 한 후 로드할 수 있다.

Component 구조

컴포넌트는 유니크한 네임스페이스로 조직적이며, 컴포넌트의 네임스페이스가 컴포넌트 이름과 동일하다.

기본적으로 컴포넌트는 컴포넌트컨트롤러와 디스크립터로 구성한다. 컴포넌트컨트롤러는 필수지만, SAP 는 디스크립터도 또한 사용하길 추천한다.

디스크립터는 컴포넌트 메타데이터를 포함하며, 또한 컴포넌트의 의존성, 설정을 나타낸다. 컴포넌트의 모든 구성요소들은 Component.js와 manifest.json이 나타낸다.

SAP UI5에서의 다른 개념


  
    복합 제어
두 개념은 싱글 인터페이스 뒤에서 제어하는 걸 제공한다. 복합 제어는 컨트롤러 내에서 재사용을 목적으로 하며, 컴포넌트는 응용프로그램 개발을 재사용으로 하며 복합제어는 기존 제어를 포함한다.
  
  
    UI 라이브러리
컨트롤 주위에 배포 가능한 단위이다. 컨트롤은 전혀 독립적이지 않고 제어 라이브러리의 부분으로서 배포된다. 그러나 컴포넌트는 자체 포함되므로, 컨트롤들을 배포하는데 사용하면 안된다.
  
  
    MVC
MVC 개념은 뷰, 컨트롤러를 정의해 부품을 구조화하여 재사용되게 허락한다. MVC는 따로따로 배포되며, 스타일과 스크립트의 정의하는 것에 의미가 없기에 이 컨셉은 다른 어플리케이션에서의 사용을 제한한다.
  


MVC


SAP UI5 에서 model, View, Controller개념은 표현을 구분하며 사용자와 상호작용을 하기 위해 사용된다. 이 구분은 개발과 부분 독립적 변화에 용이하다.


  view는 UI에 렌더링하는 일을 담당한다.
  model은 어플리케이션 데이터를 관리한다.
  controller는 view와 model에 대한 이벤트에 반응하고 변화를 상호작용한다.


UI에 안에 데이터를 바인딩 하는 목적은 사용자 인터페이스, 어플리케이션에 의한 데이터 노출, 데이터 프로세스에 의한 비즈니스 로직 코드에 대한 정의를 분리하기 위해서다. 분리를 통해서 가독성, 유지보수성, 확장성을 제공한다. 그리고 비즈니스 로직을 건들지 않고 view를 바꾸며 동일 데이터에 대해 여러 view를 분리한다.

View와 Controller는 1:1 매핑관계이다. 그러나 이것은 컨트롤러 단에서는 관계를 유지하지 않아도 된다. 이러한 컨트롤러는 어플리케이션 컨트롤러이다. 기술적 관점에서는 SAPUI5 모델을 제어하거나 상속할 수가 있다.

View와 Controller는 재사용이 가능하며 지원이 매우 좋다.

프로세스 초기화


  
    SAP 안에 있는 JQuery 플러그인은 모듈화 개념, 로깅 프레임워크, 성능 측과 같은 기능을 제공한다.
  
  
    global 오브젝트인 sap가 정의된다.
  
  
    sap.ui.core.Core 클래스가 모든 의존성들과 함께 실행된다.
  
  
    실행 설정이 다른 소스로부터 결정된다.
  
  
    모든 라이브러리와 모듈 설정은 그들의 의존성들과 함께 호출된다.
  
  
    테마설정으로 로드된 각각의 라이브러리와 css 파일이 설정된 테마를 로드한다.
  
  
    모든 라이브러리와 문서가 로드되어 기다릴 때, core에 있는 initEvent 함수가 실행되며 모든 등록된 헨들러들이 실행된다.
  


초기화 준비

이를 통해 프레임 워크를 초기화 하며 3가지 방법으로 연결할 수 있다.


  ComponentSupport 모듈
sap.ui.core.CommponentSupport를 사용하는 것이다. 프레임 워크를 초기화 한 후에 코드를 실행하는 것이다.
ComponentSupport를 통해 UIComponent를 선택하여 실행하는 방법이다.


ComponentSupport를 사용하면 필요한 ComponentContainer를 생성하여 하나 이상의 UIComponent를 정의하는 걸 허락한다.


  Standalone data-sap-ui-oninit 모듈
모듈 외에 ComponentSupport 사용은, script 요소의 부트스트랩에서 init을 부를수 있는 데이터 요소로 정의할 수 있다.


oninit 모듈은 프레임워크의 프로세스가 초기화될 때의 타이밍에 로드되고 실행한다. 그 다음 우리는 모듈 안에서 추가적으로 어플리케이션을 실행할 수 있다. ( ex. 새로운 xml View 인스턴스 생성)

추가적으로 전용 init 모듈은 추가 &lt;script&gt; 인라인 태그가 필요하지 않으므로 요구사항에 따라 SAP 사이트에 게시된 CSP(Content Security Policy)를 반영할 수 있다.

attachInit 함수

attachInit 함수는 프레임워크가 초기화 된 후 바로 실행할 함수이다. 이 코드는 스크립트 인라인 태그를 나타내는 main HTML 파일안에 쓰여질 수 있다.

부트스트래핑중 추가 리스소 로딩

/&lt;context-path&gt;/resources/&lt;library-name&gt;/library.js

sap.ui.getCore().initLibrary 메서드를 호출하여 빌드 중 파일이 자동생성되게한다.

` //resources//themes//library.css`

css 또한 이 경로를 통해 실행한다.

라이브러리 동적 로드

sap.ui.getCore().loadLibrary() 메서드를 통해 런타임에 라이브러리를 로드한다.

이렇게 동적으로 라이브러리를 추가했을 땐, document.ready 이벤트 후에 엑세스가 가능하다.

SAP UI5 구성도


manifest.json

sap에선 이 파일을 app 세팅 설정이나 app이 실행되기에 필요한 중요 정보를 모아놓으라고 추천한다.
이러한 접근을 사용하는 것은 어플리케이션 코드를 작성하기 필요한 셋팅을 미리 준비하거나, manifest.json에 미리 인스턴스화하여 앱 실행 전에 미리 정보를 엑세스 할 수 있다.

몇몇 속성은 각각 SAPUI5 버전에 필요 정보의 목적이며, 외부 구성요소와 어플리케이션을 정확하게 통합하지만, 대부분의 속성들은 실제로 최소한의 UI5 version에 필요하도록 설정이 사용된다.

Root View (App.view.xml)

App.view.xml는 app에서의 root view를 정의한다. 대부분의 경우 App Control 또는 root control로서의 SplitApp control에 포함한다.

SAP UI5는 다양한 뷰타입들을 지원한다. 컨트롤러 파일 안에 정의된 View로부터 컨트롤러 로직을 작동하기 위해 SAP에선 XML을 추천한다. ex) App.controller.js

Component.js

Component.js 파일은 앱 설정을 위한 파일이며 컴포넌트가 인스턴스화 되었을 때 SAPUI5에서 자동으로 init 함수가 실행된다.
(우리가 생성하는 Component는 UIComponent에 상속되어있으며, 만약 init을 오버라이딩 하겠다면, 너는 라우터의 초기화와 UIComponent의 init 함수가 확실히 불려져야 한다.)

컴포넌트의 metadata 섹션에서는, 디스크립터 참조를 정의하며, 컴포넌트가 인스턴스화 되었을 때, 이 디스크립터는 자동으로 로드된다.

HTML Page

App for FLP

모든 앱은 SAP UI5 그리고 그 요소를 사용하는 HTML 페이지로 시작된다. 그리고 이는 FLP 와 standalone app 라는 2가지 옵션이 있다.

FLP는 디스크립터 파일에서 주어진 정보를 기반으로 요소들을 인스턴스화한다. FLP는 같은 시간에 여러 앱들을 포함하며, 각각의 앱들은 각자의 테마와 지원장치들을 각각 로컬 셋팅으로 정의할 수 있다.

Standalone app

standalone을 실행하길 원하면 component.index.html을 인스턴스한 파일을 생성하는 것이 필요하다.

순서

SAP UI5 Tutorial 참조 사이트 (hello world 호출 까지의 과정))

ui5 serve 명령어를 실행하면 제일 먼저 index.html 파일을 로드한다.
1. index.html

(html content ...)
&lt;script
id="sap-ui-bootstrap"
src="https://openui5.hana.ondemand.com/resources/sap-ui-core.js"
data-sap-ui-theme="sap_belize"
data-sap-ui-libs="sap.m"
data-sap-ui-compatVersion="edge"
data-sap-ui-async="true"
data-sap-ui-resourceroots='{"sap.ui.demo.walkthrough": "./"}'
data-sap-ui-oninit="module:sap/ui/demo/walkthrough/index"&gt;
&lt;/script&gt;
(html contents ...)
&lt;body  class="sapUiBody"  id="content"&gt;
(html contents ...)


index.html에 설정 해 놓은 &lt;script&gt; 태그 내 실행, 속성 값

  src : SAP UI5 에서 지원하는 CDN 경로 호출
  theme : ui에 사용할 테마 설정
  libs : 기본으로 사용할 라이브러리 설정
  compatVersion : 호환성 정의
  async : 비동기 설정 유무
  resource-root : 네임스페이스 경로 alias 설정
  oninit : 첫 시작 모듈 설정


data-sap-ui-resourceroots='{"sap.ui.demo.walkthrough": "./"}'
data-sap-ui-oninit="module:sap/ui/demo/walkthrough/index


sap/ui/demo/walkthrough 경로를 ./ 로 설정하였고,
oninit 속성에 따라 페이지 실행 시 현재 파일 경로에 있는 index.js 파일을 실행한다.

2. index.js

sap.ui.define([
	"sap/ui/core/mvc/XMLView"
], function(XMLView) {
	'use strict';
	XMLView.create({
		viewName:  "sap.ui.demo.walkthrough.view.App"
	}).then(function(oView) {
		oView.placeAt("content");
	});
	});
);


sap.ui.define을 통해 호출 시, 정의할 내용을 입력한다.
sap/ui/core/mvc/XMLView는 core.js에서 지원하는 XMLView 타입을 선언하고
함수를 통해 XMLView를 생성하게 한다.
create 함수로 viewName 을 정의하며 sap.ui.demo.walkthrough.view.App 경로에 정의한 App 이란 이름의 빈 xml을 생성한다.

3. App.View.xml

&lt;mvc:View
	controllerName="sap.ui.demo.walkthrough.controller.App"
	xmlns="sap.m"
	xmlns:mvc="sap.ui.core.mvc"&gt;
	&lt;Button
		text="click"
		press=".onShowHello"/&gt;
&lt;/mvc:View&gt;


View와 Controller는 1:1 매핑이므로 controllerName으로 App.controller.js를 매핑하며
App.view.xml이 페이지에 로드되었을 때  App.controller.js 가 인스턴스화된다.

4. App.Controller.js

sap.ui.define([
	"sap/ui/core/mvc/Controller",
	.
	. 정의 타입들
	.
], function ( 정의 타입들) {
	"use strict"; // 코드 검사를 강화시켜 스크립트 오류 방지
	return Controller.extend("sap.ui.demo.walkthrough.controller.App", {
		onInit : function () {
		... Controller 호출 시 실행될 코드
		},
		onShowHello :  function () {
		MessageToast.show("Hello World");
		}
	});
});


Controller에서도 각종 sap 지원 기능 태그들을 정의해주며
함수를 통해 Controller.extend 를 호출하면서 각종 XML 출력에 필요한 로직들을 진행한다.

생각

잠깐 동안 UI5 만졌을 땐, 현 웹에서 사용하는 구조와 크게과 다르지 않았으며, 눈에띄는 차이는 view에서 xml을 호출할 때 Controller를 인스턴스화 하는 방식에 조금 신기했었다. hello world 출력을 기반으로 아직은 장단점에 대해 크게 파악하기 어려웠다,
제가 생각하는 장점에선 SAP UI5가 고퀄리티 프레임워크라 느꼈던 것이 각 하나하나의 View의 태그 생성하는 과정에 대해 디테일한 설정을 가져갈 수 있다는 것과 프론트 단 부분을 sap.m 같은 라이브러리를 통해 대부분 구성해 놓은 것을 사용할 수 있다는 점에서 UI5를 만들 때 신경을 많이 두었다는 느낌이 들었다.
또한 설정에 대한 내용을 디스크립터에 넣는 방식으로 일일히 설정에 대해 파고 들어갈 이유가 없었던 것도 좋은 방식이라 생각한다.

허나 sap로 만든 사이트중 하나를 들어가 봤는데 페이지 로딩 속도가 느렸다. 제가 생각하는 이유는 UI5도 하나의 프레임워크 방식이기에 페이지 로딩 방식이 고정되어 있어, javascript의 DOM을 BOM을 받아 파싱해서 쉽고 빠르게 화면에 뿌려주는 것을 생각하면 템플릿에 맞춰야 하는 상황이 느릴 수도 있다 생각한다. 또한 View 타입의 형태에 맞춰 Controller를 진행하는 과정이 끝날 때까지 기다려서 출력하는 구조라고 생각한다. 그렇기 에 때문에 대표님께서 말씀하신 NextJs 같이 SSR을 통해 템플릿을 프리로딩하고 이후 CSR을 진행하는 방식을 접했을 때 어느 정도까지의 퍼포먼스를 보여줄 수 있을 지 궁금하다.

                        </a>
                        <div class="info-post">
                                <a href="/Sap" class="category">Sap</a>
                            
                                <span class="date">· 2023-01-06</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Sap/sapui5/2023-01-06-OData%20V2%20Model.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/sap_thumbnail.png') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Sap/sapui5/2023-01-06-OData%20V2%20Model.html"><h1 class="title_post">OData V2 Model</h1></a>
                        <a href="/Sap/sapui5/2023-01-06-OData%20V2%20Model.html" class="txt_post">
                            oData V2 model

oData V2 모델을 사용하면 oData Service로 부터 데이터 제어를 가져올 수 있다.

oData V2 모델은 서버측의 모델이며 데이터 셋은 단지 서버에서 사용가능하고 클라이언트들은 단순히 요청된 데이터만 알 수 있다. 각 정렬과 필터링 작동은 서버 위에 올라간다. 클라이언트는 서버에 요청을 보내고 응답한 데이터를 보인다.

백앤드 요청은 바인딩 목록, 컨텍스트 바인딩들, 그리고 CRUD 함수들이 ODataModel에 의해 제공된다. 속성 바인딩은 요청이 되지 않는다.

OData model은 현재 2.0 버전까지 지원한다.

2가지 버전의 OData 모델은 sap.ui.model.odata.ODataModel 과 sap.ui.model.odata.v2.ODataModel을 참조한다. v2.ODataModel은 기능이 더해졌고, 참조된 이 모델 안에서 새로운 기능을 참조만 할 것이다. sap.ui.model.odata.ODataModel은 지원되지 않으며 SAP는 v2.ODataModel 만 사용할 것을 추천한다.


  
    
      기능
      v2.ODataModel
      ODataModel
    
  
  
    
      OData version 지원
      2.0
      2.0
    
    
      JSON format
      Yes
      Yes
    
    
      XML format
      Yes
      Yes
    
    
      양방향 바인딩 지원
      속성 변경만 가능
      하나의 엔티티 속성만 동시변경 가능
    
    
      기본 바인딩
      단방향
      단방향
    
    
      클라이언트 사이드 정렬, 필터링
      Yes
      NO
    
    
      batch
      모든 요청들은 배치될 수 있다.
      단지 메뉴얼 배치 요청만 가능
    
    
      데이터 캐시
      모델 안의 모든 데이터가 캐시된다.
      메뉴얼적 요청된 데이터는 캐시되지 않는다.
    
    
      자동 새로고침
      yes
      yes
    
    
      메세지 핸들링
      yes
      no
    
  


다른 도메인이나 사이트에서의 백앤드가 엑세스 하는 것을 막는 Same-Origin-Policy 보안개념을 유의해야한다.

패치 데이터의 서비스 요청들은  데이터 바인딩을 제어를 위해 정의를 기반으로하여 자동으로 만들어졌다.

ODataModel 생성자   
new sap.ui.model.odata.v2.ODataModel(vServiceUrl, mParameters?)  
vServiceUrl : 추가된 URL 파라미터들은 모든 요청을 덧붙일 것이다.
만약 오브젝트를 전달하고 싶을 땐, 이것은 두번째 파라미터 오브젝트로써 해석될 것이다. 그땐 mParameter.serviceUrl은 필수 파라미터가 된다.

모델 인스턴스 생성
하나의 OData 모델 인스턴스는 단지 하나의 OData service를 커버할 수 있다.
다양한 서비스를 엑세스 하기 위해선 다양한 OData Model을 인스턴스 해야한다.

// "ODataModel" required from module "sap/ui/model/odata/v2/ODataModel"
var oModel = new ODataModel("http://services.odata.org/Northwind/Northwind.svc/");
var oModel = new ODataModel({serviceUrl: "http://services.odata.org/Northwind/Northwind.svc"});

ODataModel 인스턴스를 생성할 때 서비스 메타데이터를 검색하라는 요청이 전송된다.

Service Metadata

서비스 메타데이터는 서비스 URL 별로 캐싱된다. 같은 서비스에서 사용하는 여러 OData 모델은 이 메타데이터를 공유할 수 있다.

첫번째 모델 인스턴스만 메타데이터 요청을 작동한다. JSON 서비스 메타데이터 응답은 getServiceMetadata() 라는 OData 모델 인스턴스의 메소드를 호출함으로 엑세스 될 수 있다.
var oMetadata = oModel.getServiceMetadata();

v2.ODataModel 안에서 서비스 메타데이터는 비동기식으로 불러지며 동기식으로 불러올 수 없다. 로딩이 끝났을 때, metadataLoaded 이벤트가 붙는다.

추가 URL 파라미터

OData Service는, URL 파라미터를 설정해서 사용할 수 있다. UI5는 각각의 바인딩에 따라서 파라미터들을 자동적으로 설정한다.

인증토큰이나 일반 설정 옵션들 같은 경우엔 요청 URL에 요소들을 추가할 수 있다.

몇몇 파라미터들은 모든 요청에 포함되선 안되며, $expand 또는 $select와 같은 특정 목록이나 컨텍스트 바인딩에 추가되어야한다. 바인딩 메서드는 특별한 바인딩을 위한 모든 요청을 포함할 수 있는 파라미터 맵을 전달하는 옵션을 제공한다. OData 모델은 현재 $expand와 $select를 지원한다.

URL 파라미터들을 요청하는데 2가지 방법이 있다.

파라미터들을 service URL에 추가

new ODataModel("http://myserver/MyService.svc/?myParam=value&amp;myParam2=value");


이 파라미터들은 OData 서버에 보내지는 모든 요청이 포함될 것이다.

mparameter map과 함께 URL 파라미터 전달

$metadata 요청(metadataUrlParams)이 사용되며 게다가 데이터 요청에 포함된 URL 파라미터(serviceUrlParams)를 전달할 수 있다. 파라미터들은 Map 형식으로 보내진다.

// "ODataModel" required from module "sap/ui/model/odata/v2/ODataModel"
var oModel = new ODataModel({ 
    serviceUrl: "http://services.odata.org/Northwind/Northwind.svc",    
    serviceUrlParams: {
        myParam: "value1",
        myParam2: "value2"
    },
    metadataUrlParams: {
        myParam: "value1",
        myParam2: "value2"
    }
});


HTTP HEADER

각 요청에 보내어지는 커스텀 헤더를 추가할 수 있다.

맵 파라미터와 함꼐 커스텀 헤더로 전달

var oModel = new sap.ui.model.odata.v2.ODataModel({
    headers: {
        "myHeader1" : "value1",
        "myHeader2" : "value2"
    }
});


모델 인스턴스를 글로벌 커스템헤더로 셋팅

oModel.setHeaders({"myHeader1" : "value1", "myHeader2" : "value2"});


커스텀 헤더 추가 시 이전 모든 커스텀 헤더들은 지워진다. 일부 헤더들은 private이며 즉, OData모델 내부적으로 설정되어 설정할 수 없다.

엔티티 주소 : 바인딩 경로 구문

OData 모델의 바인딩 경로 구문은 특정 엔티티들이나 엔티티 집합을 엑세스한 OData 안의 사용되는 서비스 URL과 상대적 URL 경로와 일치한다.

서비스의 메타데이터 안에 정의된 OData 서비스의 구조에 따른 OData에 의해 제공되어진다.

필터들과 같은 URL 파라미터들은 바인딩 경로를 추가할 수 없다. 바인딩 경로는 절대적이거나 상대적이다. 절대적 바인딩 경로는 즉시 리졸브 되지만, 상대경로는 절대경로에서 절대적 바인딩 경로를 자동적으로 전환될 수 있을 때 리졸브 될 수 있다. 만약 예를 들어 속성이 상대 경로에 바인딩 되고 그 부모 제어가 절대적 경로에 바운드 된다면, 상대적 경로는 절대적 경로를 통해 해결될 수 있다.

OData Model 내 바인딩 샘플은 Northwind 데모 서비스에서 부터 가져온다.


  절대적 바인딩 경로


"/Customers"
"/Customers('ALFKI')/Address"


  컨텍스트에서 확인할 수 있는 상대적 바인딩 경로


"CompanyName"
"Address"
"Orders"



  전체 경로


"/Customer('ALFKI')/CompanyName"
"/Customer('ALFKI')/Address"
"/Customer('ALFKI')/Orders"



  단일 엔티티 또는 엔티티들의 컬렉션이 사용되는 탐색 속성


"/Customers('ALFKI')/Orders"
"/Products(1)/Supplier"


OData Model로부터 데이터 엑세스

OData 서비스에서 요청한 데이터는 OData 모델에 캐시된다. getProperty() 메서드에 의해 엑세스 될 수 있으며, 엔티티 객체 또는 값을 리턴한다. 이 메서드는 백앤드로부터 요청한 데이터가 아니며, 단지 미리 요청되거나 캐시된 엔티티들로 엑세스 될 수 있다.
oModel.getProperty("/Customer('ALFKI')/Address")


이 메소드들로 싱글엔티티들과 속성들을 엑세스 할 수 있다. 엔티티 집합들을 엑세스하면, 바인딩 목록으로 읽기 전용 엔티티들을 바인딩 컨텍스트로 가져올 수 있다. 이 메서드가 리턴한 값들은 JSON 모델 안에서 참조된 것이 아닌 카피된 데이터이다.

엔티티 생성
createEntity() 메서드를 호출하면 명시된 엔티티 집합에 대한 엔티티들을 호출한다. 이 메서드는 새로 만들어진 엔티티를 가리키는 컨텍스트 객체를 반환한다.

이 어플리케이션은 이러한 객체들을 바인딩 할 수 있고 양뱡향으로 데이터들을 변경할 수 있다. submitChanges() 라고 불리는 메서드를 호출하면, OData 백앤드 안에 엔티티들을 저장한다. 변경을 초기화하려면 deleteCreateEntry() 함수를 부르면 된다.
var oContext = oModel.createEntry(
        "/Products",
        { properties:
            { ID:99,
              Name:"Product",
              Description:"new Product",
              ReleaseDate:new  Date(), 
              Price:"10.1", 
              Rating:1
            }
        }
);  // 명시된 속성들과 값을 가진 제품들의 엔티티 생성

oForm.setBindingContext(oContext); // 엔티티 바인딩

oModel.submitChanges({success: mySuccessHandler, error: myErrorHandler}); // Odata 백앤드 안에 엔티티 저장

entity oModel.deleteCreatedEntry(oContext); // 변경 취소 시 호출

만약 엔티티들을 submit 하면 컨텍스트는 모델에 import 된 새로운 데이터를 모델로 가져온다. 새로운 엔티티를 가리킨다.

CRUD 작동

OData 모델은 OData Service에서 메뉴얼적인 작업을 허용한다. 메뉴얼적 작업이 데이터를 반환할 때는 Odata 모델 데이터의 캐시가 import 된다. 모든 작업들은 필수적 sPath 파라미터와 mParameters Map을 선택적으로 요구한다.

또한, 생성, 수정 메소드들은 데이터 객체가 생성되거나 변경될 때 OData 파라미터를 필수적으로 요구한다. 각각의 작업은 요청 중단을 사용할 수 있는 중단함수를 포함한 객체를 반환한다. 만약 요청이 중단되어 에러 핸들러가 호출된다면, 이것은 성공 또는 에러 핸들러가 모든 요청에 대해 호출되도록 보장한다. 이것은 또한 헤더 데이터, URL 파라미터, 또는 eTag에 대해 추가적으로 보낼 수 있도록 한다.


  엔티티들 생성
create 함수는 OData 모델의 생성이 명시된 OData service의 POST 요청을 작동시킨다. 어플리케이션은 새로운 엔티티와 생성된 엔티티 데이터를 엔티티 셋으로 가진다.


var oData = { ProductId: 999, ProductName: "myProduct" } // 엔티티 데이터
oModel.create("/Products", oData, {success: mySuccessHandler, error: myErrorHandler}); // 엔티티들을 create()를 통해 명시된 모델로 생성한다.



  엔티티 읽기
read 함수는 GET 요청으로 작동된다. 이 경로는 OData model에 의해 생성에서 명시된 OData service로 부터 가져온다. 이 가져온 데이터는 성공여부에 따라 success handler와 error handler로 나뉜다.


oModel.read("/Products(999)", {success: mySuccessHandler, error: myErrorHandler});



  엔티티 수정 
update 함수는 PUT/MERGE 요청으로 작동하며 성공적으로 요청이 된 후에는 model 안에서 refresh 된 데이터를 자동으로 가져온다.


oModel.update("/Products(999)", oData, {success: mySuccessHandler, error: myErrorHandler});



  엔티티 삭제
delete 함수는 DELETE 요청으로 작동하며, 어플리케이션에서는 삭제해야할 엔트리의 경로를 명시해야한다.


oModel.remove("/Products(999)", {success: mySuccessHandler, error: myErrorHandler});



  변경 후 refresh


모델은 변화된 엔티티들을 의존하여 자동적으로 refresh를 바인딩하는 메커니즘을 제공한다. 만약 create, update, remove 함수를 수행하면, 그 고유의 모델은 바인딩을 확인하며 이를 위해 refresh를 작동한다. 만약 그 모델이 배치모드에서 실행되면, 새로고친 요청은 같은 배치 요청 안의 변화들과 함께 묶이게 된다. setRefreshAfterChange(false) 호출에 의해 자동으로 비활성화 할 수 있다. 만약 자동 고침이 비활성화 되었을 때, 어플리케이션은 각각의 바인딩들을 새로고쳐야 한다.


  자식 엔티티 생성


부모 엔티티에 새로운 자식 엔티티 생성은 한번의 싱글 API 요청으로 가능하지 않다. 이를 만들려면 부모, 자식의 생성 엔티티 API 호출을 연결하면 만들 수 있고 아래의 샘플은 판매 주문과 주문 항목을 모두 생성한다.

var oParentContext, oModel = this.getView().getModel(); 

oParentContext = oModel.createEntry("SalesOrderSet", { //부모 엔티티 생성
	properties : {
		 // 새로운 판매 주문을 위한 속성
	},
	success : function () { // 부모(oParentContext)가 생성되었을 때
		oChildContext = oModel.createEntry("ToLineItems", { //자식 엔티티 생성
			context : oParentContext, // context에 부모의 컨텍스트 저장
			properties : { 
				// 새로운 판매 주문에 의한 새로운 아이템들의 속성
			},
			success : function () {
				// ...
			}
		});
		oModel.submitChanges(); // OData 백앤드에 저장
	}
});

oModel.submitChanges(); // OData 백앤드에 저장



동시성 제어 와 ETags

OData는 optimistic한 동시성 제어를 HTTP ETags를 사용한다. ETag는 모든 CRUD 요청을 위해서 parameter map으로 전달될 수 있다. 만약 ETag가 전달되지 않으면, 미리 로드된 경우, 캐시된 엔티티가 사용된다.

XSRF Token

CSRF 를 해결하기 위해 OData 서비스는 데이터 변경 시 XSRF 토큰을 필요로 한다. 이 경우 서버에서 가져온 토큰을 같이 서버에 보내야 하며 OData 모델은 메타데이터를 읽을때, XSRF 토큰을 가져와 header에 넣어 자동으로 토큰을 전송한다. 토큰이 유효하지 않을때엔, OData Model에서 refreshToken 함수를 호출하여 패치될 수 있다. 이 토큰은 루트 URL 서비스의 호출과 함께 가져오며 서비스 다큐먼트와 함께 응답한다. 유효한 토큰을 가져오려면 응답이 캐싱되지 않았는지 확인해야한다.

모델의 새로고침

refresh 함수는 OData 모델의 모든 데이터를 새로고침한다. 각각의 바인딩은 서버로부터 데이터를 다시 읽는다. 리스트 또는 컨텍스트 바인딩 경우, 백앤드에서 새로운 요청이 작동된다. 만약 XSRF 토큰이 유효하지 않으면, 서비스 다큐먼트에서 읽기 요청을 다시 가져와야 한다. 메뉴얼 CRUD 요청들로 임포트된 데이터는 자동으로 리로드 되지 않는다.

배치 프로세싱

ODataModel v2는 2가지 다른 방법으로 batch processing을 지원한다.


  
    기본 : 쓰레드안에 모든 요청들은 배치 요청들로 수집되고 다뤄진다. 즉, 요청은 현재 스택이 종료된 후에 타임아웃 요청을 보낸다. 이것은 바인딩에 의해 작동된 요청들로부터 모든 메뉴얼적 CRUD 요청들을 포함한다.
  
  
    지연 : 요청들은 저장되며 어플리케이션의 의해 호출되는 submitChanges() 과 함께 submit 되어질 수 있다. 이것은 또한 바인딩으로 부터 요청들이 작동될 뿐만 아니라, 모든 메뉴얼적 CRUD 요청들이 포함된다.
  


모델이 요청을 다루는 방법은 결정할 수 없다. 그래서 SAPUI5는 groupId를 제공한다. 각각의 컨텍스트와 바인딩 리스트 그리고 각각 메뉴얼 요청들에 그룹 아이디를 지정할 수 있다. 같은 그룹안에 속하는 모든 요청들은 하나의 요청 안에서 다뤄질 수 있다. 그룹아이디가 없는 요청은 기본 배치 그룹 안에서 다뤄진다. 변경을 위해 chageSetId 를 사용할 수 있다. 같은 changeSetId에 포함된 각 변경들은 배치 요청안에서 하나의 changeSet으로 다뤄진다. 기본적으로, 모든 변화들은 고유의 changeSet을 가진다.

setDefiredGroup() 메서드를 사용하여 이전에 정의된 그룹의 서브셋을 지연으로 설정할 수 있다. (setChangeGroups() , getChangeGroups() 에도 동일 시 적용)

그룹에 속한 모든 요청들은 요청 queue안에 저장된다. 
지연된 배치 그룹은 submitChanges() 메소드를 통해 메뉴얼적으로 전송되어야한다. 만약 submitChanges()를 호출할 때 배치 그룹아이디를 명시하지 않으면, 모든 지연된 배치 그룹들이 전송된다.

- 그룹들의 서브셋을 지연으로 설정
	var oModel = new ODataModel(myServiceUrl);

- 바인딩한 groupId를 전송한다.
	{path:"/myEntities", parameters: {groupId: "myId"}}

- 지연한 groupId 설정
	1. 그룹 가져오기
		var aDeferredGroups = oModel.getDeferredGroups();
	2. 리스트에 그룹 아이디 추가
		aDeferredGroups = aaDeferredGroups.concat(["myId"]);
	3. 지연된 모든 그룹들을 설정
		oModel.setDeferredGroups(aDeferredGroups);
	4. 지연된 모든 그룹 전송
		oModel.submitChanges({success: mySuccessHandler, error: myErrorHandler});


양방향 바인딩

v2.oDataModel은 양방향 바인딩을 지원한다. 기본적으로 모든 변경들은 지연으로 설정된 changes 라는 배치그룹에 수집된다.

changes 로 전송하려면, submitChanges() 함수를 사용한다. changes 데이터는 복사 데이터로 만들어진다. 이것은 이전 데이터를 가져와 백앤드에 새 요청을 보내지 않고도 changes를 재설정 할 수 있다. resetChanges() 써서 모든 changes 저장공간을 리셋할 수 있다. 또한 엔티티 경로 배열이 있는 resetChanges() 함수를 호출하여 특정 엔티티만 리셋할 수 있다.

model에서 setChangeGroups() 를 사용하면, 다른 배치 그룹안에 있는 다른 엔티티들 또는 타입들을 위한 changes도 수집할 수 있다.
var oModel = new ODataModel(myServiceUrl); 
	oModel.setDeferredGroups(["myGroupId", "myGroupId2"]); 
	oModel.setChangeGroups({ 
		"EntityTypeName": {
			 groupId: "myGroupId", // 
			 changeSetId: "ID", // 선택사항 (Id 변경)
			 single: true, /*optional, can be true or false*/ 
		}
	});
oModel.submitChanges({groupId: "myGroupId", success: mySuccessHandler, error: myErrorHandler});


같은 배치 그룹 안에서 모든 엔티티 타입을 위한 changes 수집은 ‘*‘를 EntityType으로 사용한다. 만약 change가 지연으로 설정하지 않으면, changes는 즉시 백앤드에 보내어진다. 단일 파라미터를 true 또는 false로 설정에 의해 , 고유의 change 설정 안에 각각의 change 결과들이거나 changes가 하나의 change 설정을 수집할 것인지를 정의한다. 모델은 단지 single의 설정이 false 일 때만 changeSetId를 처리한다.
var oModel = new ODataModel(myServiceUrl);

oModel.setProperty("/myEntity(0)", oValue);

oModel.resetChanges(["/myEntity(0)"]);


바인딩별 매개변수

OData 프로토콜은 명시적으로 다른 URL 파라미터이다.

위에서 설명한 파라미터들 뿐만 아니라 바인딩 안에 파라미터들을 사용할 수 있다.


  Expand parameter


확장 파라미터는 어플리케이션에서 그들의 네비게이션 속성들과 함께 연결된 엔티티들을 읽는 걸 허락한다.

oControl.bindElement("/Category(1)", {expand: "Products"}); 

oTable.bindRows({
    path: "/Products",
    parameters: {expand: "Category"}
});


예로 Category(1) 의 모든 제품들은 서버 응답안에 inline으로 내장되어 하나의 요청만 부른다. 모든 Products 위한 카테고리는 각각의 product 위한 응답에 inline으로 내장되어있다.


  Select parameter


선택 파라미터는 어플리케이션이 엔티티를 요청할 때 읽는 속성들의 서브셋으로 정의하는 것을 허락한다.
oControl.bindElement("/Category(1)", {expand: "Products", select: "Name,ID,Products"}); 
oTable.bindRows({ path: "/Products", parameters: {select: "Name,Category"} });

예를 들어 Name, ID 그리고 ofCategory(1) 속성 뿐만 아니라 제품에 내장된 모든 속성들도 응답한다. 이 속성과 카테고리는 각각의 제품에 포함되며 카테고리 속성은 관련된 카테고리 항목에 대한 링크를 포함한다.


  Custom query options


서비스 작동을 위한 input 파라미터로서 커스텀 쿼리 옵션들을 사용할 수 있다. list 바인딩이 생성될 때, 커스텀 파라미터를 명시한다.
oTable.bindRows({
		path: "/Products",
		parameters: { 
		custom: { // 커스텀 파라미터 명시
			param1: "value1",
			param2: "value2"
		}
	},
	template: rowTemplate
});


만약 bindElement()를 사용하면, 아래와 같이 파라미터를 명시할 수 있다.
oTextField.bindElement("/GetProducts", {
	custom: {
		"price" : "500"
	}
});


바인딩 의존 최적화

OData V2 모델 에서 생성자는 preliminaryContext 라 불리는 flag를 지원한다. 이 옵션이 true 이면, 모델은 더 적은 $batch 요청 종속적 바인딩에 대한 OData 호출을 다를 수 있게 된다.

소개

부모 바인딩이 의존 바인딩에 설정된 컨텍스트에 해당하는 OData 엔티티를 읽는다면 다른 바인딩(부모바인딩) 에 의존한다.

기본적으로 종속 바인딩을 위한 데이터는 바인딩 컨텍스트를 위한 데이터를 부모 바인딩를 통해 읽은 후에만 읽는다.

부모 바인딩이 컨텍스트 바인딩인 경우, 2개의 읽기 요청을 하나의 번들링으로 퍼포먼스를 증가시킬 수 있다. 바인딩과 연결된 단일 컨텍스트는 예비의 컨텍스트를 명시하여 수행할 수 있다. 이를 위해 부모 바인딩 구성에 createPreliminaryContext 파라미터 설정이 필요하다. 의존적 리스트 또는 컨텍스트 바인딩은 데이터를 읽기 전에 preliminaryContext 경로를 사용하여 데이터를 읽어 그들 자신의 요청을 위한 경로 구성을 주문 할 수 있다. 의존 바인딩의 생성을 usePreliminaryContext 파라미터를 설정해 수행한다.

설정과 사용

OData V2 model을 생성할 떄 preliminaryContext 파라미터를 설정할 수있다. 이 모델을 위해 생성된 모든 바인딩의 preliminary 컨텍스트를 전환한다.


  모든 컨텍스트 바인딩은 createPreliminaryContext 파라미터를 true로 가진다.
  모든 컨텍스트 바인딩과 모든 바인딩 목록은 usePreliminaryContext 파라미터를 true로 설정한다.


ODataContextBinding 생성자 또는 ODataListBinding 생성자에 해당하는 파라미터들의 기본을 무시할 수 있다.
게다가 모델에 일반적 preliminaryContext 파라미터를 사용하지 않을 수도 있다. (모든 바인딩에 영향을 미친다)

그러나 이러한 매개변수 사용하는 바인딩 인스턴스와 부모쌍에 대한 preliminaryContext를 바꾼다.

예를 들면, 부모 바인딩인 “/Product{1}” 경로를 가진 컨텍스트 바인딩을 보여준다.(sap.m.Panel 경로로 바인딩된 컨텍스트들을 생성) ‘Supplier’ 경로를 가진 의존적 관련 바인딩은 product의 모든 supplier를 보여주는 테이블로 생성된다. ( sap.ui.table.Table 제어 위한 행 을 생성)


싱글 바인딩 예제

표에 따르면, preliminaryContext들을 사용하지 않고, Binding 0 위한 하나의 요청, 그리고 나중에 Binding 1 위한 하나, 두개 연속으로 OData 요청들이 이슈가 된다.


  
    
      요청 넘버
      요소
    
  
  
    
      1
      GET Product(1)
    
    
      1
      GET Product(1)/Supplier
    
  


아래에서 보여주는 바인딩 매개변수를 설정하여 요청을 최적화 할 수 있다.


싱글 바인딩 예제 최적화

여기 Binding 1은 Binding 0이 생성될 때 preliminaryContext를 사용하며, 그리고 이와같이 요청 URL 은 다이렉트로 해결될 수 있다.
| 요청 넘버 | 요소 |
|:–:|:–:|
|1| GET Product(1),GET Product(1)/Supplier|

함수 임포트
ODataModel은 callFunction() 메소드에 의해 임포트나 또는 액션 함수들의 부르는 것을 지원한다.
oModel.callFunction("/GetProductsByRating",{method:"GET", urlParameters:{"rating":3}, success:fnSuccess, error: fnError})


만약 callFunction() 요청이 지연되면, submitChangesmethod()를 통해 전송되어 질 수 있다.

파라미터를 가져오는 함수의 바인딩

OData Model V2는 파라미터들을 가져오는 함수에 대해 바인딩을 지원한다. 엔티티 속성에 대해 바인딩을 지원하는 createEntry() 메서드와 비슷하다. callFunction() 메서드는 promise를 가진 핸들을 반환한다. 그 promise는 바인딩된 컨텍스트가 성공적으로 생성되거나 또는 거부될 때 해결된다.

var oHandle = oModel.callFunction("/GetProductsByRating", {urlParameters: {rating:3}});
oHandle.contextCreated().then(function(oContext) {
	oView.setBindingContext(oContext); 
});


만약 함수가 결과 데이터를 가져오면, 그때 그 결과 데이터는 엑세스 되고 컨텍스트 사용 속성 $result 에 대해 묶인다.
&lt;form:SimpleForm&gt;
	&lt;core:Title text="Parameters" /&gt;
	&lt;Label text="Rating" /&gt;
	&lt;Input value="{rating}" /&gt;
	&lt;Button text="Submit" press=".submit" /&gt;
	&lt;core:Title text="Result" /&gt;
	&lt;List items="{$result}"&gt;
	&lt;StandardListItem title="{Name}" /&gt;
	&lt;/List&gt;
&lt;/form:SimpleForm&gt;


언어

SAPUI5는 현재 언어의 컨셉으로 사용한다. 이 언어는 자동적으로 OData V2 model에 의해 OData service로 전달된다. 이 이유로 어플리케이션은 언어 자체를 하드 코드로 해서 안된다. 예로 커스텀 쿼리 옵션에 ‘sap-language’ URL 파라미터를 명시해서는 안된다.

OData V2위한 메타 모델

sap.ui.model.odata.ODataMetaModel의 구현은 OData V2 metadata, 그리고 V4 어노테이션 둘다 통일된 엑세스로 제공한다.

메타모델은 기존 sap.ui.model.odata.ODataMetadata 기반으로 사용하며 엔티티나 또는 속성에 직접적으로 상승하는 기존 sap.ui.model.odata.ODataAnnotations로부터의 OData Version 4.0을 병합한다.

기본 구조

sap.ui.model.odata.ODataMetadata 의 기본 구조는 코드 스니핑에 따라서 보여진다. 이것은 엔티티 모델이 중첩되는 가장 중요한 요소가 어떻게 되는지 보여준다.
각각의 요소들은 약간의 네임스페이스로 부터 XML 속성 값의 확장성을 가질 수 있다. 아래 코드스니핑은 이러한 확장성들이 어떻게 저장되고 처리되는 지를 보여준다.

"dataServices": {
    "schema": [{
      "association": [{
        "end": []
      }],
      "complexType": [{
        "property": []
      }],
      "entityContainer": [{
        "associationSet": [{
          "end": []
        }],
        "entitySet": [],
        "functionImport": [{
          "parameter": []
        }]
      }],
      "entityType": [{
        "property": [],
        "navigationProperty": []
      }]
    }]
  }


객체, 속성 엑세스

OData 메타 모델 안에 객체들은 배열로 처리된다. 예로 ‘/dataService/schema’는 각각 스키마가 엔티티 타입, 등등의 배열과 함께 엔티티 타입 속성을 가지는 스키마들의 배열이다. 그래서 ‘/dataServices/schema/0/entityType/16’은 ‘MySchema’ 네임스페이스가 스키마 내 이름이 ‘Order’인 엔티티 타입의 경로가 될 수 있다.

그러나 이 경로들은 안정적이지 않다. 만약 낮은 인덱스를 가진 엔티티 타입이 스키마로부터 제거되었을 때, ‘Order’ 경로는 ‘/dataServices/schema/0/entityType/15/’ 로 변한다. index가 변하는 문제를 피하기 위해서 getObject 나 getProperty는 인덱스를 위한, XPath 같은 쿼리를 지원한다. 각각의 인덱스는 대괄호 안 쿼리에 의해 대체될 수 있다.

예를 들어
경로를 사용하는 스키마 주소
/dataServices/schema/[${namespace}==='MySchema']

경로를 사용하는 엔티티 주소
/dataServices/schema/[${namespace}==='MySchema']/entityType/[${name}==='Order']

를 지정하여 사용할 수 있다.

대괄호 안의 구문은 바인딩 구문의 표현식이랑 일치한다. 쿼리는 결과가 true로 될 때까지 각 객체들을 위해 실행된다. 그 다음 객체가 선택되면 
이 경로를 복잡한 바인딩 구문을 사용하여 바인딩 식에 끼워넣는다.
`${path:'...'}`.
Example: `{:= ${path:'target&gt;extensions/[${name} === \'semantics\']/value'} === 'email'}`


이러한 각 쿼리들은 자체적으로 포함되어있다. 쿼리는 관련 경로를 통해서 현재 후보의 속성에 언급할 수 있다. 그러나 XML 탬플릿 안에서 이용가능한 ${meta&gt;} 와 같은 변수들은 언급할 수 없다.

확장자

확장 배열과 SAP 사용해 단순 속성의 객체로 변환: 이전에 속성 이름들을 추가 ex) 8번쨰 라인 참조
1  {
2    "name": "BusinessPartnerID",
3    "extensions": [{
4      "name": "label",
5      "value": "Bus. Part. ID",
6      "namespace": "http://www.sap.com/Protocols/SAPData"
7    }],
8    "sap:label": "Bus. Part. ID"
9  }


OData V4 어노테이션

엔티티 모델의 각각 요소는 어노테이션을 달 수 있다. 기존 sap.ui.model.odata.ODataAnnotations 로 부터의 어노테이션은 해당 요소에 직접적으로 병합된다.  
아래 코드는 위에서 설명한 것처럼 기존 sap.ui.model.odata.ODataMetadata로부터의 구조를 보여준다.
"dataServices" : {
    "schema" : [{
        "namespace" : "GWSAMPLE_BASIC",
        "entityType" : [{
            "name" : "Product",
            "property" : [{
                "name" : "ProductID",
                "type" : "Edm.String",
                "nullable" : "false",
                "maxLength" : "10"
            }, {
                "name" : "SupplierName",
                "type" : "Edm.String",
                "maxLength" : "80",
                "extensions" : [{
                  "name" : "label",
                  "value" : "Company Name",
                  "namespace" : "http://www.sap.com/Protocols/SAPData"
                }, {
                  "name" : "creatable",
                  "value" : "false",
                  "namespace" : "http://www.sap.com/Protocols/SAPData"
                }, {
                  "name" : "updatable",
                  "value" : "false",
                  "namespace" : "http://www.sap.com/Protocols/SAPData"
                }],
                "sap:label" : "Company Name",
                "sap:creatable" : "false",
                "sap:updatable" : "false"
                "Org.OData.Core.V1.Computed" : {
                    "Bool" : "true"
                }
            }, {
                "name" : "WeightMeasure",
                "type" : "Edm.Decimal",
                "precision" : "13",
                "scale" : "3",
                "Org.OData.Measures.V1.Unit" : {
                    "Path" : "WeightUnit"
                }
            }, {
                "name" : "WeightUnit",
                "type" : "Edm.String",
                "maxLength" : "3"
            }],
            "com.sap.vocabularies.UI.v1.DataPoint" : {
                "Value" : {
                    "Path" : "WeightMeasure",
                    "EdmType" : "Edm.Decimal"
                }
            },
            "com.sap.vocabularies.UI.v1.Identification" : [{
                "Value" : {"Path" : "ProductID"}
            }, {
                "Value" : {"Path" : "SupplierName"}
            }, {
                "Value" : {"Path" : "WeightMeasure"}
            }]
        }]
    }]
}

OData Meta Model의 향상

각 sap:label 과 같이 기본 용어에 해당하는 SAP-specific OData 어노테이션에 쉽게 접근하는데다가, 어노테이션은 기존 sap.ui.model.odata.ODataAnnotations의 OData 버전 4.0 어노테이션 안에서 정의 되지 않았을 때에서만 믹스된다.

OData V2 내 통화 및 단위 정의

양이나 치수 는 CLDR에 정의된 것 보다 다른 통화, 또는 단위가 필요할 수 있다.

The sap.ui.model.odata.type.Currency 그리고 sap.ui.model.odata.type.Unit 데이터 타입들은 통화 코드 그리고 단위를 커스터마이징 할 때 코드목록을 사용할 수 있다.

통화 또는 유닛 커스터마이징 하는 코드 목록의 경우 어노테이션들 정의해야한다.

OData V4 시나리오와 대조적으로 OData V2는 코드 리스트 서비스를 허용하지 않는다. 모든 메터데이터 정보는 기본 metadata.xml 파일에 포함되어야 하며, 코드리스트 URL은 단지 이 파일만을 가리켜야 한다. 이것은 다음과 같이 URL 속성을 명시하여 수행된다.

&lt;PropertyValue Property="Url" String="./$metadata"/&gt;

com.sap.vocabularies.CodeList.v1.CurrencyCodes 또는 com.sap.vocabularies.CodeList.v1.UnitsOfMeasure 어노테이션이 참조된 코드리스트는 이것들이 필요하다.


  유일한 키 속성인 내부 코드
  의존적 언어 설명
  특정 단위 숫자 속성
  옵션 : 내부 코드 대신 보여지는 외부 코드
  옵션 : 표준 코드
키 속성 문서화:
  설명 속성을 가리키는 com.sap.vocabularies.Common.v1.Text
  숫자 속성을 가리키는 com.sap.vocabularies.Common.v1.UnitSpecificScale
  표준 코드를 가리키는 com.sap.vocabularies.CodeList.v1.StandardCode


어노테이션 안의 경로 속성은 엔티티 타입 안 속성들을 참조해야하는 것을 명심해야한다. 네비게이션 속성을 포함하는 경로는 지원되지 않는다.

대체키가 가능할 때 타입은 통화 또는 단위의 키로서 대신 사용한다. 이 경우엔, 그 서비스는 통화 또는 단위 속성안에서 대체 키 묘사를 포함해야 한다. 대체키가 주석이 달리지 않았을 땐, 키는 데이터 안에서 사용, 예상된다. 최대 하나의 키를 가져야 하며, 키와 대체키는 정확히 하나여야 한다.

com.sap.vocabularies.CodeList.v1.StandardCode 로서 문서화된 속성은 sap.ui.model.odata.type.Currency 에서  ISO 코드로  해석된다. 그리고 통화 상징을 찾는데 사용된다. 이 통화 상징은 데이터 입력에 사용된다.

service’s metadata.xml 파일 내 통화 코드와 단위 코드 리스트 문서
...
&lt;edmx:Include Namespace="com.sap.vocabularies.Common.v1" Alias="SAP__common"/&gt;
&lt;edmx:Include Namespace="Org.OData.Core.V1" Alias="SAP__core"/&gt;
&lt;edmx:Include Namespace="com.sap.vocabularies.CodeList.v1" Alias="SAP__CodeList"/&gt;
...
&lt;EntityType Name="Product"&gt;
    ...
    &lt;Property Name="WeightMeasure" Type="Edm.Decimal" Precision="13" Scale="3" /&gt;
    &lt;Property Name="WeightUnit" Type="Edm.String" MaxLength="3" /&gt;
    &lt;Property Name="CurrencyCode" Type="Edm.String" Nullable="false" MaxLength="5" /&gt;
    &lt;Property Name="Price" Type="Edm.Decimal" Precision="16" Scale="3" /&gt; 
    ...
&lt;/EntityType&gt;
...
&lt;EntityType Name="SAP__Currency" sap:content-version="1"&gt;
&lt;Key&gt;
    &lt;PropertyRef Name="CurrencyCode"/&gt;
&lt;/Key&gt;
    &lt;Property Name="CurrencyCode" Type="Edm.String" Nullable="false" MaxLength="5" sap:label="Currency" sap:semantics="currency-code"/&gt;
    &lt;Property Name="ISOCode" Type="Edm.String" Nullable="false" MaxLength="3" sap:label="ISO Code"/&gt;
    &lt;Property Name="Text" Type="Edm.String" Nullable="false" MaxLength="15" sap:label="Short Text"/&gt;
    &lt;Property Name="DecimalPlaces" Type="Edm.Byte" Nullable="false" sap:label="Decimals"/&gt;
&lt;/EntityType&gt;
 
&lt;EntityType Name="SAP__UnitOfMeasure" sap:content-version="1"&gt;
&lt;Key&gt;
    &lt;PropertyRef Name="UnitCode"/&gt;
&lt;/Key&gt;
    &lt;Property Name="UnitCode" Type="Edm.String" Nullable="false" MaxLength="3" sap:label="Internal UoM" sap:semantics="unit-of-measure"/&gt;
    &lt;Property Name="ISOCode" Type="Edm.String" Nullable="false" MaxLength="3" sap:label="ISO Code"/&gt;
    &lt;Property Name="ExternalCode" Type="Edm.String" Nullable="false" MaxLength="3" sap:label="Commercial"/&gt;
    &lt;Property Name="Text" Type="Edm.String" Nullable="false" MaxLength="30" sap:label="UoM Text"/&gt;
    &lt;Property Name="DecimalPlaces" Type="Edm.Int16" sap:label="Decimal Places"/&gt;
&lt;/EntityType&gt;
...
&lt;EntityContainer Name="GWSAMPLE_BASIC_Entities" m:IsDefaultEntityContainer="true" sap:message-scope-supported="true" sap:supported-formats="atom json xlsx"&gt;
&lt;EntitySet Name="ProductSet" EntityType="GWSAMPLE_BASIC.Product" sap:content-version="1"/&gt;
...
&lt;EntitySet Name="SAP__Currencies" EntityType="GWSAMPLE_BASIC.SAP__Currency" sap:creatable="false" sap:updatable="false" sap:deletable="false" sap:pageable="false" sap:content-version="1"/&gt;
&lt;EntitySet Name="SAP__UnitsOfMeasure" EntityType="GWSAMPLE_BASIC.SAP__UnitOfMeasure" sap:creatable="false" sap:updatable="false" sap:deletable="false" sap:pageable="false" sap:content-version="1"/&gt;
...
&lt;Annotations
    xmlns="http://docs.oasis-open.org/odata/ns/edm"
    Target="GWSAMPLE_BASIC.GWSAMPLE_BASIC_Entities"&gt; 
    &lt;Annotation Term="SAP__CodeList.CurrencyCodes"&gt;
        &lt;Record&gt;
            &lt;PropertyValue Property="Url" String="./$metadata"/&gt;
            &lt;PropertyValue Property="CollectionPath" String="SAP__Currencies"/&gt;
        &lt;/Record&gt;
    &lt;/Annotation&gt;
    &lt;Annotation Term="SAP__CodeList.UnitsOfMeasure"&gt;
        &lt;Record&gt;
            &lt;PropertyValue Property="Url" String="./$metadata"/&gt;
            &lt;PropertyValue Property="CollectionPath" String="SAP__UnitsOfMeasure"/&gt;
        &lt;/Record&gt;
    &lt;/Annotation&gt;
&lt;/Annotations&gt;

&lt;Annotations Target="SAP__self.Currency/CurrencyCode"&gt;
    &lt;Annotation Term="Common.Text" Path="Text" /&gt;
    &lt;Annotation Term="Common.UnitSpecificScale" Path="DecimalPlaces" /&gt;
    &lt;Annotation Term="CodeList.StandardCode" Path="ISOCode" /&gt;
&lt;/Annotations&gt;
  
&lt;Annotations
    xmlns="http://docs.oasis-open.org/odata/ns/edm"
    Target="GWSAMPLE_BASIC.SAP__UnitOfMeasure/UnitCode"&gt;
    &lt;Annotation Term="Common.Text" Path="Text" /&gt;
    &lt;Annotation Term="Common.UnitSpecificScale" Path="DecimalPlaces" /&gt;
    &lt;Annotation Term="CodeList.StandardCode" PropertyPath="ISOCode" /&gt;
    &lt;Annotation Term="CodeList.ExternalCode" PropertyPath="ExternalCode" /&gt;
&lt;/Annotations&gt;
  
&lt;Annotations 
    xmlns="http://docs.oasis-open.org/odata/ns/edm"
    Target="GWSAMPLE_BASIC.SAP__UnitOfMeasure"&gt;
    &lt;Annotation Term="Core.AlternateKeys"&gt;
      &lt;Collection&gt;
        &lt;Record&gt;
          &lt;PropertyValue Property="Key"&gt;
            &lt;Collection&gt;
              &lt;Record&gt;
                &lt;PropertyValue Property="Name" PropertyPath="ExternalCode" /&gt;
                &lt;PropertyValue Property="Alias" String="ExternalCode" /&gt;
              &lt;Record&gt;
            &lt;/Collection&gt;
          &lt;/PropertyValue&gt;
        &lt;Record&gt;
      &lt;/Collection&gt;
    &lt;/Annotation&gt;
&lt;/Annotations&gt;
...

위 메타데이터를 통해 sap.ui.model.odata.type.Currency 와 sap.ui.model.odata.type.Unit 같은 입력 필드의 데이터 타입을 사용할 수 있다. 데이터 타입들은 금액 또는 측정을 첫번째로, 통화코드 또는 단위를 두번째로, 그리고 커스텀한 코드리스트 정보를 세번째로 하여 정보를 합쳐 사용한다.

...
&lt;Input value="{
   mode:'TwoWay', 
   parts:[
      'WeightMeasure', 
      'WeightUnit', 
      {
         mode:'OneTime', 
         path:'/##@@requestUnitsOfMeasure', 
         targetType:'any'}], 
   type:'sap.ui.model.odata.type.Unit'}"/&gt;
...
&lt;Input value="{
   mode:'TwoWay', 
   parts:[
      'Price', 
      'CurrencyCode', 
      {
         mode:'OneTime', 
         path:'/##@@requestCurrencyCodes', 
         targetType:'any'}], 
   type:'sap.ui.model.odata.type.Currency'}"/&gt;
...


코드리스트는 브라우저 세션 및 코드목록 URL당 한번만 자동으로 요청된다.


                        </a>
                        <div class="info-post">
                                <a href="/Sap" class="category">Sap</a>
                            
                                <span class="date">· 2023-01-06</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Java/Live-Study/2023-01-06-live-study9.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/java_thumbnail.png') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Java/Live-Study/2023-01-06-live-study9.html"><h1 class="title_post">자바의 예외 처리</h1></a>
                        <a href="/Java/Live-Study/2023-01-06-live-study9.html" class="txt_post">
                            목적

자바의 예외 처리에 대해 학습하세요.

학습할 것


  자바에서 예외 처리 방법 (try, catch, throw, throws, finally)
  자바가 제공하는 예외 계층 구조
  Exception과 Error의 차이는?
  RuntimeException과 RE가 아닌 것의 차이는?
  커스텀한 예외 만드는 방법


1. 자바에서 예외 처리 방법 (try, catch, throw, throws, finally)



2. 자바가 제공하는 예외 계층 구조



3. Exception과 Error의 차이는?



4. RuntimeException과 RE가 아닌 것의 차이는?



5. 커스텀한 예외 만드는 방법



Reference

남궁성. Java의 정석

                        </a>
                        <div class="info-post">
                                <a href="/Java" class="category">Java</a>
                            
                                <span class="date">· 2023-01-06</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Java/Live-Study/2023-01-06-live-study8.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/java_thumbnail.png') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Java/Live-Study/2023-01-06-live-study8.html"><h1 class="title_post">자바의 인터페이스</h1></a>
                        <a href="/Java/Live-Study/2023-01-06-live-study8.html" class="txt_post">
                            목적

자바의 인터페이스에 대해 학습하세요.

학습할 것


  인터페이스 정의하는 방법
  인터페이스 구현하는 방법
  인터페이스 레퍼런스를 통해 구현체를 사용하는 방법
  인터페이스 상속
  인터페이스의 기본 메소드 (Default Method), 자바 8
  인터페이스의 static 메소드, 자바 8
  인터페이스의 private 메소드, 자바 9


인터페이스란

인터페이스는 일종의 추상 클래스로 추상클래스보다 추상화 정도가 높아 일반 메서드 또는 멤버변수 (몸통)을 가질 수 없다 오직 추상메서드와 상수만 멤버로 가질 수 있다. 비유하자면 밑그림만 그려져있는 기본 설계도 라 할수있다.

1. 인터페이스 정의하는 방법



interface 인터페이스 이름{
	public static final 타입상수이름 = 값;
	public abstract 메서드이름(매개변수 목록);
}


인터페이스는 클래스랑 달리 제약사항이 있다.


  모든 멤버변수는 public static final 이어야 하며, 이를 생략할 수 있다.
  모든 메서드는 public abstract 이어야 하며 생략할 수 있다. (static 메서드와 default 메서드 예외)
  위의 static 메서드와 default 메서드는 JDK 1.8에서 지원한다.


2. 인터페이스 구현하는 방법



인터페이스는 그 자체로 생성할 수 없고, 자신의 몸통을 만들어줘야 한다.

public interface Player{
	public void move(int x, int y);
	public void shoot(int x, int y);
}


class NBAPlayer implements Player{
	public void move(int x, int y){
 		System.out.println("x, y 좌표로 이동");       
    }
	public void shoot(int x, int y){
 		System.out.println("x, y 방향으로 슛!");        
    }
}


인터페이스의 메서드 중 일부만 구현하고 싶다면 abstract 붙여서 추상클래스로 선언해야 한다.

abstract class RunningPlayer implements Player{
	public void move(int x, int y);
}


3.  인터페이스 레퍼런스를 통해 구현체를 사용하는 방법



문제의 뜻을 잘 이해하지 못했는데 일단 내가 해석한 것은 main에서 인터페이스 같은경우 어떻게 선언하는 것인지 같아 적어본다.

public static void main(String[] args){
    Player Lebron = new NBAPlayer();
    lebron.move();
    lebron.shoot();
}


x, y 좌표로 이동
x, y 방향으로 슛!


NBAPlayer()라는 클래스는 Player라는 인터페이스를 참조하고 있으므로 인터페이스 변수 선언에 참조된 클래스를 생성하여 사용할 수 있다.(?)

4. 인터페이스 상속



인터페이스는 인터페이스로부터만 상속받을 수 있으며 클래스와는 달리 다중상속, 여러개의 인터페이스로부터 상속받는 것은 불가능하다.

interface Moving{
	void move(int x, int y);
}

interface Shooting{
    void shoot(int x, int y);
}

interface Player extends Moving, Shooting{}


클래스의 상속과 마찬가지로 자손 인터페이스는 조상인터페이스에 정의된 멤버를 모두 상속받아 Player 인터페이스는move와 shoot을 다 가진 인터페이스가 된다.

5.  인터페이스의 기본 메소드(Default Method) 자바 8



조상클래스에 메서드 추가는 쉽지만 인터페이스는 어렵다. 인터페이스에 메서드 추가는 그 인터페이스를 참조하는 모든 클래스들이 새로 추가된 메서드를 구현해야 하기 때문이다. 그래서 디폴트 메서드가 나왔으며 이는 추상 메서드의 기본적 구현을 제공하는 메서드로 참조중인 클래스를 변경하지 않아도 된다.

interface MyInterface{
	void method();
	default void newMethod();
}


대신 이때 기존 메서드와 디폴트 메서드가 이름이 중복되어 충돌할 수도 있다.


  여러 인터페이스의 디폴트 메서드 간의 충돌
    
      인터페이스를 구현한 클래스에서 디폴트 메서드를 오버라이딩해야 한다.
    
  
  디폴트 메서드와 조상 클래스의 메서드 간의 충돌
    
      조상 클래스의 메서드가 상속되고, 디폴트 메서드는 무시된다.
    
  


라는 규칙이 있는데 간단히 필요한 쪽의 메서드와 같은 내용으로 오버라이딩 해버리면 된다.

6.  인터페이스의 static 메소드, 자바8



static 메소드 같은 경우는 인스턴스와 관계가 없는 독립적 메서드로 인터페이스에 추가하면 된다.

그리고 인터페이스의 static메서드 역시 접근 제어자가 항상 public이며 생략할 수 있다.

7. 인터페이스의 private 메소드, 자바 9



java 8에서는 default, static method는 기본으로 public 만 가능했고 java 9 버전부턴 private 메서드를 지원한다.

이는 인터페이스가 내부적으로 처리하는 문제를 외부에서 사용하지 못하게 만들어준다.

결과적으로 인터페이스에 캡슐화시켜준다 할 수 있다.

Reference

남궁성. Java의 정석

                        </a>
                        <div class="info-post">
                                <a href="/Java" class="category">Java</a>
                            
                                <span class="date">· 2023-01-06</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Java/Live-Study/2023-01-06-live-study7.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/java_thumbnail.png') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Java/Live-Study/2023-01-06-live-study7.html"><h1 class="title_post">자바의 패키지</h1></a>
                        <a href="/Java/Live-Study/2023-01-06-live-study7.html" class="txt_post">
                            목적

자바의 패키지에 대해 학습하세요.

학습할 것


  package 키워드
  import 키워드
  클래스패스
  CLASSPATH 환경변수
  -classpath 옵션
  접근지시자


1. package 키워드



패키지

패키지는 클래스랑 인터페이스의 모음이며 관련된 클래스끼리 그룹단위로 모아 효율적인 관리를 할 수 있다.

패키지가 다르면 클래스명이 같아도 구분할 수 있다.

클래스가 물리적으로 하나의 클래스파일(.class).인 것과 같이 패키지는 물리적으로 하나의 디렉토리이다.

하나의 소스파일에 첫 번째 문장으로 단 한 번의 패키지 선언만을 허용한다.

모든 클래스는 반드시 하나의 패키지에 속해야 한다.

패키지는 점(.)을 구분자로 하여 계층구조를 구성할 수 있다.

패키지는 물리적으로 클래스 파일(.class)을 포함하는 하나의 디렉토리이다.

패키지 선언

패키지 선언은 아래 한 줄을 맨 첫번째 줄에 적어주면 된다.

package 패키지명;


2. import키워드



import문

다른 패키지의 클래스를 사용하려 한다면 패키지명이 포함된 클래스 이름을 사용해야 한다. import의 역할은 컴파일러에게 소스파일에 사용된 클래스의 패키지에 대한 정보를 제공하는 것이다. 이클립스에서 Ctrl + Shift + o 누르면 자동으로 import 해준다.(근데 자동완성에 익숙해져서 잘 안쓸거 같다.)

import문 선언

import 패키지명.클래스명; //한 클래스만 사용할 때
import 패키지명.*; // 패키지 안에 여러클래스를 사용할 때


패키지명.*; 을 사용한다 하면 그안의 모든 클래스들을 로드해 필요없는 클래스도 import 할거라 생각하지만, 실행시 성능에 이상이 없다.

static import문

static import는 static 멤버를 호출할 때 클래스 이름을 생략하게 해준다. 예로

import static java.lang.Math.random;


선언 시,

Math.random(); -&gt; random();


처럼 바꿔준다.

3. 클래스패스



간단히 말해서 클래스를 찾기 위한 경로이다.

우리는 프로그램을 실행하면 메모리를 할당받고 JVM을 동작시킨다.

컴파일러를 실행하게 되면 JVM이 동작하게 된다. JVM은 .java 파일들을  클래스 파일들을 찾는데 그때의 파일 경로의 기준이 된다. 그리고 이를 지정해주는 방법은 classpath 환경변수, -classpath 옵션 두가지가 있다.

4. CLASSPATH 환경변수



JVM 클래스 로더는 classpath 경로를 찾아가 그 안에 정의된 class들을 가져온다.

이 것을 지정해주는 법은 os의 시스템 변수 부분 Path의 값에 %JAVA_HOME%/bin 이라는 값을 추가해주면 등록된다.

5. -classpath 옵션



자바에서 컴파일 할 때 classpath를 정해서 갈 수 있다.

java c -classpath '경로' java파일명


이라는 명령어를 통해서 classpath의 옵션을 지정한다.즉, 다른 클래스에 의존하는 클래스 파일을 컴파일 하기 위해 그 클래스의 경로를 직접 매핑해준다.

6. 접근지시자 (접근제어자)



멤버 또는 클래스에 사용되며, 해당하는 멤버 또는 클래스를 외부에서 접근하지 못하도록 제한하는 역할을 한다.

접근제어자가 사용될 수 있는 곳 - 클래스, 멤버변수, 메서드 생성자


  
    
      제어자
      같은 클래스
      같은 패키지
      자손클래스
      전 체
    
  
  
    
      public
      O
      O
      O
      O
    
    
      protected
      O
      O
      O
       
    
    
      (default)
      O
      O
       
       
    
    
      private
      O
       
       
       
    
  


public : 접근제한이 전혀 없다.

private : 같은 클래스 내에서만 사용하도록 제한

default : 같은 패키지 내의 클래스에서만 접근 가능

protected : 패키지에 관계없이 상속관계에 있는 자손클래스에서 접근할 수 있도록 하는 것이 제한목적이지만, 같은 패키지내에서도 접근이 가능하다. 결과적으로 protected가 default보다 접근범위가 더 넓다.

접근 제어자를 이용한 캡슐화

접근제어자를 왜 사용하냐 : 클래스 내부에 선언된 데이터를 보호하기 위해서이다. 데이터가 유효한 값을 유지하도록, 비밀번호와 같은 데이터를 외부에서 함부로 변경하지 못하도록 하기 위해서이며 이것을 데이터 감추기라 부르기도 한다.

외부에는 불필요한, 내부적으로만 사용되는 부분을 감추기 위해서도 사용된다.

예를들어

public class Time{
	public int hour;
	public int minute;
	public int second;
}


클래스가 있고 인스턴스 생성 후 멤버변수에 직접 접근하면 값을 변경할 수 있다.

Time t = new Time();
t.hour = 25;


위 코드처럼 hour에 25라는 잘못된 값을 지정한다 해도 막을 방법이 없다.

이럴 때는 private나 protected로 제한하고 값을 읽고 변경할 수 있는 public 메서드를 제공함으로써 간접적으로 멤버변수의 값을 다룰 수 있도록 한다.

public void set Hour(int hour){
    if (hour &lt; 0 || hour &gt; 23){
        return ;
    }
    this.hour = hour;
}


만일 상속을 통해 확장될 것이 예상되는 클래스라면, 멤버에 접근 제한을 주되 자손 클래스에서 접근하는 것이 가능하도록 하기 위해 private 대신 protected를 사용한다.

생성자의 접근 제어자

생성자에 접근 제어자를 사용함으로 인스턴스 생성을 제한할 수도 있다.

생성자의 접근 제어자를 private 로 지정하면 외부에서 인스턴스를 생성할 수 없게 된다.

class SingleTon{
	private SingleTon() {
	}
}


대신 인스턴스를 생성해서 반환해주는 public 메서드를 제공해 외부에서 이 클래스의 인스턴스를 사용할 수 있도록 할 수 있다. 이 메서드는 public 인 동시에 static 이어야 한다.

class Singleton(){
	private static Singleton s = new Singleton();
	private Singleton(){
	}

	public static Singleton getInstance(){
		return s;
	}
}


또 생성자가 private인 클래스는 다른 클래스의 조상이 될 수 없다. 자손클래스가 인스턴스를 생성할 때 조상클래스의 생성자를 호출해야 하는데 private는 같은 클래스 내에서만 가능하기 때문이다. 따라서 클래스 앞에 final을 더 추가해 상속할 수 없는 클래스인 것을 알려주는 것이 좋다.

제어자의 조합


  
    
      대 상
      사용 가능한 제어자
    
  
  
    
      클래스
      public, (default), final, abstract
    
    
      메서드
      모든 접근 제어자, final, abstract, static
    
    
      멤버변수
      모든 접근 제어자, final, static
    
    
      지역변수
      final
    
  



  메서드에 static과 abstract를 함께 사용할 수 없다.


static 메서드는 구현된 메서드에서만 사용할 수 있기 때문에


  클래스에 abstract와 final을 동시에 사용할 수 없다.


클래스에서 사용되는 final은 확장을 없애는 의미이고 abstract는 상속을 통해서 완성되기에 모순된다.


  abstract메서드의 접근 제어자가 private일 수 없다.


abstract 메서드는 자손 클래스를 구현해주어야 하는데 접근 제어자가 private 이면 자손에 접근할 수가 없다.


  메서드에 private가 final을 같이 사용할 수 없다.


접근 제어자가 private인 메서드는 오버라이딩 될 수 없다.

Reference

남궁성. Java의 정석

                        </a>
                        <div class="info-post">
                                <a href="/Java" class="category">Java</a>
                            
                                <span class="date">· 2023-01-06</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Java/Live-Study/2023-01-06-live-study6.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/java_thumbnail.png') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Java/Live-Study/2023-01-06-live-study6.html"><h1 class="title_post">자바의 상속</h1></a>
                        <a href="/Java/Live-Study/2023-01-06-live-study6.html" class="txt_post">
                            목적

자바의 상속에 대해 학습하세요.

학습할 것


  자바 상속의 특징
  super 키워드
  메소드 오버라이딩
  다이나믹 메소드 디스패치 (Dynamic Method Dispatch)
  추상 클래스
  final 키워드
  Object 클래스


1. 자바 상속의 특징



자바의 상속 전, 상속이란, 기존 클래스를 재사용하여 새로운 클래스를 작성하는 것이다. 이는 코드의 재사용성을 높이고 중복을 제거하여 생산성과 유지성에 크게 기여한다.


  
    단일 상속
  


다른 객체지향 언어인 C++ 에서는 여러 조상 클래스로부터 상속받는 것이 가능한 ‘다중상속’을 허용하지만, 자바는 오직 단일 상속만 허용한다. 만약 다중 상속을 허용하게 된다면 클래스 내 인스턴스 메서드를 구별할 방법이 없다. 이처럼 명확하고 신뢰성 있는 코드를 위해 다중 상속의 장점을 포기하며 단일 상속을 지원한다.


  
    상속 횟수 제한 X
  


자바에서는 상속에 제한을 두지 않는다.


  
    최상의 클래스
  


자바에서는 모든 상속계층도의 최상위에 Object 클래스가 위치한다. 따라서 Object 클래스에 정의된 멤버들을 사용할 수 있다.

2. super 키워드



super란 자손 클래스에서 조상 클래스로부터 상속받은 멤버를 참조하는데 사용되는 참조변수이다.

멤버변수와 지역변수의 이름이 같을 때 this를 붙여서 구별했듯이, 상속받은 멤버와 자신의 멤버가 같을 떈 super를 붙여서 구별한다.

조상 클래스 멤버와 자손 클래스의 멤버가 중복 정의되어 서로 구별해야 하는 경우에만 super를 사용하는 것이 좋다.

super는 static 메서드에선 사용할 수 없다.

조상 클래스에서 선언된 멤버변수와 같은 이름의 멤버변수를 가진 자손 클래스엔 중복되게 정의가 가능하며 super를 사용해 구별해준다.

메서드 역시 super를 사용하여 호출할 수 도있다.

ex) super.getName();


생성자에서는 super()는 생성자이고 조상 클래스의 생성자를 호출하는데 사용된다. 그리고 자손 클래스의 멤버가 조상 클래스의 멤버를 사용할 수 있으므로 조상의 멤버가 먼저 초기화 되어야 한다. (super() 가 가장 먼저 선언되어야 하는 이유) 혹시나 적어놓지 않았으면 컴파일러가 자동으로 추가해준다.

만약 조상 클래스의 값들을 가지고 생성자를 호출하고 싶다면 super(변수, 변수 …) 이런 식으로 호출하면 된다.

3. 메소드 오버라이딩



오버라이딩이란 상속받은 메서드의 내용을 변경하여 사용하는 것이다. 자손 클래스에 맞게 변경해야 하는 경우가 많고 이럴 때 오버라이딩을 사용한다.

오버라이딩의 조건을 성립시키기 위해선 3가지 조건이 맞아야 한다.


  이름이 같아야 한다.
  매개변수가 같아야 한다.
  반환타입이 같아야 한다.


요약하면 선언부가 일치해야 한다고 말할 수 있고 접근 제어자와 예외같은 경우는 제한된 조건이 있다.


  접근 제어자는 조상 클래스 메서드보다 좁은 범위로 변경할 수 없다.
  예외는 조상 클래스의 메서드보다 많이 선언할 수 없다.
  인스턴스메서드와 static 메서드를 서로 변경해서 사용할 수 없다.


(static 같은 경우는 오버라이딩이 아니라 그냥 static 메서드를 정의 한 것이다. )

4. 다이나믹 메소드 디스패치



다이나믹 메소드 디스패치에 대한 정보가 안나와서 나름 다른 분들의 글과 인터넷 검색을 통해서 찾아 보았고 정확한 정보를 알 순 없었다.

허나 일단 글대로 적자면,

다이나믹 메소드 디스패치는 오버라이딩 되어있는 메소드를 실행할 때 런타임 시점에서 어떤 메소드를 실행할 지 결정하려는 것이다.

인터페이스를 참조한 2개의 자식 클래스가 있고, 이에 인터페이스를 생성하여 그 안의 함수를 실행시켰을 때, 과연 2개의 자식 클래스 중 누가 호출되는 것인 지를 컴파일러가 알 수 없는 것이다.

5. 추상 클래스



추상 클래스는 클래스에 정의할 내용을 추상적으로 적어놓은, 즉 설계도의 틀 이라고 생각하면 좋다. 추상클래스는 상속을 통해서 자손 클래스에 의해서만 완성될 수 있다. 추상 클래스는 클래스 앞에 abstract를 붙이면 된다. 긜고 상속을 통해 구현해주면 완성된다. 또한 추상클래스에서도 생성자가 있으며, 멤버변수와 메서드도 가질 수 있다.

abstract class 클래스이름 {
}


스포츠를 예시로 들자면 축구 농구 배구 등이 있고 축구 선수 배구 선수 농구 선수가 있는데 이 3명의 선수는 스포츠 선수라는 타이틀을 가지고 있고 추상화를 통해 스포츠 선수를 정의할 수 있다.

abstract class Player{
	boolean pause;
	int currentPos;
	Player(){
		pause = false;
		currentPos = 0;
	}

	abstract void play();
	abstract void stop();
}


6. final 키워드



변경될 수 없는 의미를 가지고 있는 의미이며 선언시 변경할 수 없는 상수가 된다.

메서드에 사용 시엔 오버라이딩을 할 수 없고 클래스에 사용하면 자손 클래스를 정의하지 못하게 된다.

final 사용 구간은 클래스, 메서드, 멤버변수, 지역변수 이다.

final이 붙은 변수는 상수이므로 선언과 초기화를 동시에 하지만, 인스턴스 변수의 경우 생성자에서 초기화 되도록 할 수 있다. 클래스 내에 매개변수를 갖는 생성자를 선언하여, 인스턴스를 생성할 때 final이 붙은 멤버변수를 초기화하는데 필요한 값을 생성자의 매개변수로부터 제공받는 것이다. 이를 통해 각 인스턴스마다 final이 붙은 멤버변수가 다른 값을 갖도록 하는 것이 가능하다. 이것이 불가능 하다면 final이 붙은 인스턴스 변수는 모든 인스턴스에서 같은 값이 되어야만 한다.

7. Object 클래스



Obejct 클래스는 모든 클래스의 최상위 위치에 있는 조상 클래스이다.

class Study extends Object{
}


모든 클래스들은 Object 클래스를 상속받고 있다. 이를 통해 모든 클래스는 Object 클래스에 정의된 멤버, 함수들을 사용할 수 있다.


  
    
      Object 클래스의 메서드
      설 명
    
  
  
    
      protected Object clone()
      객체 자신의 복사본을 반환한다.
    
    
      public boolean equals(Object obj)
      객체 자신과 객체 obj가 같은 객체인지 알려준다.(같으면 true)
    
    
      protected void finalize()
      객체가 소멸될 때 가비지 컬렉터에 의해 자동적으로 호출된다. 이 때 수행되어야하는 코드가 있을 때 오버라이딩 한다.(거의 사용 안함)
    
    
      public Class getClass()
      객체 자신의 클래스 정보를 담고 있는 Class인스턴스를 반환한다.
    
    
      public int hashCode()
      객체 자신의 해시코드를 반환
    
    
      public String toString()
      객체 자신의 정보를 문자열로 반환
    
    
      public void notify()
      객체 자신을 사용하려고 기다리는 쓰레드를 하나만 깨운다.
    
    
      public void notifyAll()
      객체 자신을 사용하려고 기다리는 모든 쓰레드를 깨운다.
    
    
      public void wait() public void wait(long timeout) public void wait(long time, int nanos)
      다른 쓰레드가 notify()나 notifyAll()을 호출할 떄까지 현재 쓰레드를 무한히 또는 지정된 시간(timeout, nanos)동안 기다리게 한다.
    
  


                        </a>
                        <div class="info-post">
                                <a href="/Java" class="category">Java</a>
                            
                                <span class="date">· 2023-01-06</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Java/Live-Study/2023-01-06-live-study5.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/java_thumbnail.png') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Java/Live-Study/2023-01-06-live-study5.html"><h1 class="title_post">자바의 Class</h1></a>
                        <a href="/Java/Live-Study/2023-01-06-live-study5.html" class="txt_post">
                            목적

자바의 Class에 대해 학습하세요.

학습할 것


  클래스 정의하는 방법
  객체 만드는 방법 (new 키워드 이해하기)
  메소드 정의하는 방법
  생성자 정의하는 방법
  this 키워드 이해하기


1. 클래스 정의하는 방법



클래스란, 객체를 정의해놓은 것, 또는 객체의 설계도 라고 정의할 수 있다. 그리고 클래스는 객체를 생성하는데 사용된다.

클래스를 구성하는 요소들은 필드들과 메소드, 생성자로 되어있다.

public class Account{

	private Long id;
	private String name;
	private String email;
	private String password;

    /* 생성자는 default 하게 만들 수 있지만 생성자에서 파라미터로 값을 받아서 작성 시, 반드        시 작성해주어야 한다.
    */
    public Account(String email, String password){
        this.email = email;
        this.password = password;
    }

	public String getEmail(){
		return Email;
	}

	public void changePassword(String password){
		this.password = password;
	}
}


2. 객체 만드는 방법(new 키워드 이해하기)



클래스로부터 객체를 만드는 과정을 인스턴스화 라고 하며 만들어진 객체를 그 클래스의 인스턴스라고 한다. 그리고 객체는 속성과 기능 두 종류의 구성요소로 이루어져 있으며 이들은 그 객체의 멤버라고 한다. 속성과 기능 같은 경우, 속성은 멤버변수, 기능은 메소드 라고 말한다.

클래스명 변수명; // 선언
변수명 = new 클래스명(); // 생성


기본적으로 인스턴스 생성( 객체 만들기 )는 위 코드처럼 정의하며 위 클래스를 예시로 들었을 땐,

Account account;
account = new Account(); // 기본 생성자
account = new Account("dmstjd1024@naver.com", "password") // 파라미터 있는 생성자


이런 식으로 구성된다.

3. 메소드 정의하는 법



반환타입 메서드이름 (타입 변수명, 타입변수명, ... )
{
	//메서드 호출 시 수행될 코드
}


ex)

int add (int a, int b)
{
	int result = a + b;
	return result;
}


4. 생성자 정의하는 방법



컴파일 시 소스파일에 생성자가 하나도 정의되지 않은 경우, 컴파일러는 자동적으로 아래와 같은 내용의 기본 생성자를 추가하여 컴파일 한다.

클래스이름() {}


조심해야 할 점은 클래스 내에 생성자가 하나도 없을 때 이므로 혹시나 뜬금없이 파라미터를 가진 생성자만 적어놓으면 에러가 난다.

클래스 클래스명{
	변수
	변수
	생성자(파라미터 파라미터명){
		// 에러 발생
	}
}


5. this 키워드 이해하기



생성자 간에도 서로 호출이 가능한다. 허나 2가지 조건이 필요한다.


  생성자의 이름으로 클래스이름 대신 this를 사용
  한 생성자에서 다른 생성자를 호출할 때는 반드시 첫 줄에서만 호출이 가능


ex)

Car (String color){
	door = 5;
	Car(color, "auto", 4); // X 생성자에서 다른 생성자를 호출 =&gt; this(color ....) 생성 O
}


첫줄에서만 호출 가능한 이유는 생성자 내에서 ㅗ기화 작업 도중, 다른 생성자를 호출하게 되면, 호출된 다른 생성자 내에서도 멤버변수들의 값을 초기화를 할 것이므로 다른 생성자를 호출하기 이전의 초기화 작업이 무의미해질수 있기 떄문이다.

그리고 this같은 경우는

Car(){
	this("white", "auto", 4); // 처럼 깔끔하게 적는 것이 보기 더 좋다.
}


또한 this를 이용해서 인스턴스변수에 접근할 수 있다. 허나 this는 인스턴스 변수에만 접근할 수 있다. static 메서드에서는 인스턴스를 사용할 수 없는 것처럼, this 역시 사용할 수 없다. static 메서드는 인스턴스를 생성하지 않고도 호출될 수 있기 때문이다.

정리하자면

this 인스턴스 자신을 가리키는 참조변수, 인스턴스의 주소가 저장되어 있따. 모든 인스턴스메서드에 지역변수로 숨겨진 채로 존재한다.

this(), this(매개변수) 생성자, 같은 클래스의 다른 생성자를 호출할 때 사용한다.

Reference

남궁성. Java의 정석

                        </a>
                        <div class="info-post">
                                <a href="/Java" class="category">Java</a>
                            
                                <span class="date">· 2023-01-06</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Java/Live-Study/2023-01-06-live-study4.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/java_thumbnail.png') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Java/Live-Study/2023-01-06-live-study4.html"><h1 class="title_post">제어문</h1></a>
                        <a href="/Java/Live-Study/2023-01-06-live-study4.html" class="txt_post">
                            목적

자바가 제공하는 제어문을 학습하세요

학습할 것


  선택문
  반복문


1. 선택문



Switch

if 같은 조건문은 참, 거짓밖에 없기 때문에 경우가 많아질 수록 else if를 계속 추가해야하며 else if 에 있는 조건식들을 일일히 다 계산하며 내려가야 하므로 처리 시간이 늘어난다. 이를 해결하기 위해 switch(선택)문이 있고 하나의 조건식으로 많은 수를 처리할 수 있으며 표현도 간결해 가독성이 높다.

switch문은 조건식을 먼저 계산한 다음, 결과랑 일치하는 case 문으로 이동한다. 그리고 case 문의 내용을 수행하며 break를 만났을 때 switch문을 빠져나오게 된다.

또한 조건식의 결과와 일치하는 case 문이 없는 경우, default 로 지정한 문을 찾아가 내용을 수행한다. 그렇기 때문에 default를 기마지막에 놓는다. (이렇게 하면 break문이 필요 없음)

책에서는 break문을 사용해 권한 주는 코드로도 활용할 수 있다 한다. (ex )

swich (level){
	case 3 :
		grantDelete();
	case 2 :
		grantWrite();
	case 1 :
		grantRead();
		break;
}


간단히 말해서 case에 break를 주지 않음으로 아래 권한 부여 함수들을 다 실행시킬 수 있다는 것이다.

switch 제약조건


  조건식의 결과값은 반드시 정수 또는 문자열여야 한다.
  중복되지 않아야 한다.
  case문의 값은 반드시 상수이어야 한다.


※ tip switch 안에 switch로 중첩이 가능한다.-&gt; break문 으로 탈출 조심!

2. 반복문



반복문은 반복적으로 수행될 때 사용되며, for, while, do - while이 있다.

1. for

for문은 반복 횟수를 알고 있을 때 정확한다. 구조가 복잡하지만, 직관적이라 오히려 이해하기 쉽다.

for문의 구조와 수행순서

for(초기화; 조건식; 증감식){
	수행문장
}


① 초기화 -&gt; ② 조건식 -&gt; ③ 증감식 -&gt; ④ 수행될 문장 순서대로 진행한다.

초기화

변수 초기화 하는 부분이며 처음 한번만 수행한다. ‘,’ 를 통해서 두 개 이상의 변수를 초기화 가능하다.(단 변수 타입은 같아야 한다.)

조건식

참이면 반복하고 거짓이면 반복 멈춘다. (무한루프에 빠지지않게 조건식을 잘 세워야 한다.)

증감식

반복문 제어 변수를 증감시키는 식이다. ex) i++, i==, i+=2, i* = 3

쉼표를 이용해서 두 문장 이상을 하나로 연결해 쓸 수 있다. ex) for( ~~; ~~; i++, j– )

for문에서는 for(;;){} 을 사용하면 계속 참으로 간주되어 무한 루프로 돌릴 수 있다. (break로 탈출)

항상된 for문

JDK 1.5부터 배열과 컬렉션에 저장된 요소에 접근할 때 편리한 방법의 문법이 추가되었다.

for( 타입 변수명, 배열 또는 컬렉션) {
	수행문장
}


위 for문을 사용할 때는 배열, 컬렉션 만 가능하고 안에 저장된 값들을 하나씩 읽어와 변수에 저장해 반복문이 돌아간다.

예시

for (int i=0; i &lt; arr.length; i++) -&gt; for(int tmp : arr)


2. while

while은 for문과 다르게 구조가 간단하며 참인동안 반복될 문장들을 적어놓는다.

while(조건식){
    반복될 문장
}


for문과 while문 비교

for문은 초기화, 조건식, 증감식을 한 곳에 모아놓은 것일 뿐 while문과 다르지 않아 항상 서로 형변환이 가능하다. 초기화나 증감식이 필요하지 않는 경우면 while문이 더 적합하다.

while문의 조건식은 생략 불가

때문에 while문의 조건식이 항상 참이 되도록 하려면 안에 true를 넣어주면 된다.

3. do - while

while문의 변형으로 조건식과 불럭의 순서를 바꿔놓은 것이다. 따라서 블럭이 먼저 수행한 후에 조건식을 평가한다.

do {
	수행될 문장
}while(조건식);


따라서 최소한 한번은 수행될 것을 보장한다.

4. 부가적
1.break 문

break문은 switch에서 설명 했는데 일단은 실질적인 의미로 break문은 자신이 포함된 가장 가까운 반복문을 벗어나는 문이다. 주로 if문과 함께 사용되어 특정 조건을 만족하면 반복문을 벗어나도록 한다.

2.continue 문

반복문 내에서만 사용될 수 있으며, 반복 중 continue를 만나게 되면 가장 가까운 반복문의 끝으로 이동하여 다음 반복문으로 넘어간다.

3.이름 붙은 반복문

break와 continue 같이 가장 가까운 반복문 외에 중첩되어 있는 반복문들 중에서 지정된 위치로 탈출하고 싶다 하면 break, continue문에 이름을 지정해 반복을 옮겨다닐 수 있다.

ex)

outer :
while (true) {
	...
	for(;;) {
		...
		if(num == 0)
			break;
		if(num == 99)
			break outer;
		...
	} // for(;;)

} // while(true)


num에 0을 입력하면 break;가 실행되면서 다시 for문 안의 문장들을 실행할 수 있고, num에 99를 입력했을 때는 for문에서 break outer;를 통해 for문과 while문 모두를 벗어날 수 있게 된다.

Reference

남궁성. Java의 정석

                        </a>
                        <div class="info-post">
                                <a href="/Java" class="category">Java</a>
                            
                                <span class="date">· 2023-01-06</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/Java/Live-Study/2023-01-06-live-study3.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('/assets/img/thumbnail/java_thumbnail.png') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/Java/Live-Study/2023-01-06-live-study3.html"><h1 class="title_post">연산자</h1></a>
                        <a href="/Java/Live-Study/2023-01-06-live-study3.html" class="txt_post">
                            목적

자바가 제공하는 다양한 연산자를 학습하세요.

학습할 것


  산술 연산자
  비트 연산자
  관계 연산자
  논리 연산자
  instanceof
  assignment(=) operator
  화살표(-&gt;) 연산자
  3항 연산자
  연산자 우선 순위
  (optional) Java 13. switch 연산자


산술 연산자



산술 연산자는 사칙연산을 다루는 기본적이면서도 가장 많이 사용되는 연산자 이다.

산술 연산자는 [ +, -, *, /, % ] 5가지가 있고 연산 순서는 { *, /, % } -&gt; { +, - } 이다.

사칙연산자

사친 연산자 같은 경우는 산술 연산자 중 { +, -, *, / } 로 나타낼 수 있다.

그리고 사칙 연산자에선 예시로 int 형의 연산 중 10 / 4 같은경우 우리는 2.5라 생각하지만 2라고 나온다. int타입은 소수점을 정희하지 못하으몰 정수만 남고 소수점 이하는 버려진다. 그래서 올바른 연산을 위해선 한 쪽을 실수형의 값으로 바꿔 결과를 가져야 한다.

피 연산자가 정수형인 경우, 나누는 수를 0으로 사용할 수 없다. -&gt; 컴파일 시엔 정상적이지만 실행 시 오류가 발생

이때 0을 실수형 0 인 0.0으로 나누는 것은 가능하지만 실행 시(ArthmeticException) 오류가 난다.

또 byte형 같은 경우는 연산을 시행하면 int형보다 작기 때문에 byte를 int형으로 바꿔서 연산을 수행해야 한다.

byte a = 10;
byte b = 20;
byte c = a + b;


때문에 byte c 같은 경우 int형으로 바뀐 값을 넣으려 하니 에러가 발생한다.

나머지 연산자

왼쪽 피연산자를 오른쪽 피연산자로 나누고 난 나머지 값을 결과로 반환하는 연산자로 오른쪽 피연산자를 0으로 사용할 수 없다. 주로 짝, 홀, 배수 검사등에 사용한다.

비트 연산자



비트 연산자는 피연산자를 비트단위로 논리 연산한다. 피 연산자를 이진수로 표현했을 때 각 자리를 규칙에 따라 연산을 수행하며 피 연산자로 실수는 허용하지 않는다. 정수만 허용된다.


  
    
      x
      y
      x | y
      x &amp; y
      x ^ y
    
  
  
    
      1
      1
      1
      1
      0
    
    
      1
      0
      1
      0
      1
    
    
      0
      1
      1
      0
      1
    
    
      0
      0
      0
      0
      0
    
  



  
    
      (OR 연산자) : 피연산자 중 한쪽 값이 1이면, 1의 결과를 얻는다.
    
  


&amp; (AND 연산자) : 양쪽이 1이여야 1을 결과로 얻는다.

^ (XOR 연산자) : 피연산자의 값이 서로 다를 때만 1을 결과로 얻는다.

~(전환 연산자) : 피연산자를 2진수로 표현했을 때, 0은 1로 1은 0으로 바꾼다. (보수를 얻을 때 사용)

«, » (쉬프트 연산자) : 피연산자의 각 자리(2진수를 표현했을 때)

관계 연산자



관계 연산자는 비교 연산자라 부를 수 있으며 주로 조거눔ㄴ과 반복문 조건식에 사용되며 결과는 true 아니면 false 뿐이다.

대소비교 연산자

[ &lt;, &gt;, &lt;=, &gt;= ] 두 피연산자의 값의 크기를 비교하는 연산자이다. boolean을 제외한 자료형에 다 사용할 수 있지만, 참조형에는 사용할 수 없다.

등가비교 연산자

[ ==, != ] 두 피연산자의 값이 같은지 또는 다른지 비교하는 연산자이다. 모든 자료형에 사용할 수 있고 참조형의 경우엔 객체의 주소값을 저장하기 때문에 두 개의 피연산자가 같은 객체를 가리키고 있는 지 알 수 있다.

기본형과 참조형은 서로 형변환이 가능하지 않기 때문에 등가비교 연산자(==, !=) 로 기본형과 참조형을 비교할 수 없다.

그리고 두 문자열을 비교할 땐 비교 연산자 대신 equals() 라는 메서드를 사용해야 한다. 문자열의 내용이 같은 지 비교하기 위해서이다.

논리연산자




  
    
      논리 연산자는 두개의 조건이 결합된 경우는 [ &amp;&amp;,
       
      ] 을 사용하여 나타낸다.
    
  



  
    
      x
      y
      x || y
      x &amp;&amp; y
    
  
  
    
      true
      true
      true
      true
    
    
      true
      false
      true
      false
    
    
      false
      true
      true
      false
    
    
      false
      false
      false
      false
    
  


논리연산자의 장점은 효율적인 연산을 한다는 것이다.OR 연산자를 예로 들면 두 피연산자 중 한쪽만 참이면 참이 되기 때문에 다른 쪽은 평가하지 않는다.

논리부정연산자

[ ! ] 이 연산자는 반대로 결과를 반환한다. 따라서 전원버튼이나 토글 버튼을 논리적으로 구현할 수 있다.

instance of

참조변수가 참조하고 있는 인스턴스의 실제 타입을 알아보기 위해 instanceof 연산자를 사용한다. 주로 조건문에 사용되며 식은 ( 참조변수 instanceof 클래스명) 이 피연산자로 위치한다. 어떤 타입에 대한 instanceof연산의 결과가 true라는 것은 검사한 타입으로 형변환이 가능하다는 것을 뜻한다.

그리고 자신의 조상 타입의 경우에도 true라는 결과를 얻는다.

Assignment(=) operator (할당 연산자)

할당 연산자는 대입 연산자랑 같은 말이며 변수와 같은 저장공간에 값 또는 수식의 연산결과를 저장하는데 사용된다.

할당 연산자는 연산자들 중에서 가장 낮은 우선순위를 가지고 있기 때문에 식에서 제일 나중에 수행된다. 그리고 연산 진행방향이 오른쪽에서 왼쪽이다.

그리고 연산자는 단순할당 연산자랑 복합 할당 연산자로 나뉘어져 있는데 단순 할당 연산자는 우리가 아는 = 이것이고 복합 대입 연산자는 나머지를 의미한다.

할당 연산자의 종류

=  :  오른쪽 피연산자의 값을 왼쪽 피연산자에 저장합니다.

+=  :  오른쪽 피연산자의 값을 왼쪽 피연산자와 더해서 왼쪽 피연산자에 저장합니다.

-=  :  오른쪽 피연산자의 값을 왼쪽 피연산자에서 빼서 왼쪽 피연산자에 저장합니다.

*=  :  오른쪽 피연산자의 값을 왼쪽 피연산자와 곱해서 왼쪽 피연산자에 저장합니다.

/=  :  왼쪽 피연산자를 오른쪽 피연산자로 나눠서 왼쪽 피연산자에 저장합니다.

%=  :  왼쪽 피연산자에서 오른쪽 피연산자로 나눈 나머지(모듈러스)를 왼쪽 피연산자에 저장합니다.

«=  :  오른쪽 피연산자 값의 비트수만큼 왼쪽 피연산자를 왼쪽으로 이동해서 왼쪽 피연산자에 저장합니다.

»=  :  오른쪽 피연산자 값의 비트수만큼 왼쪽 피연산자를 오른쪽으로 이동해서 왼쪽 피연산자에 저장합니다.

&amp;=  :  왼쪽, 오른쪽 피연산자의 비트 AND를 구해서 왼쪽 피연산자에 저장합니다.


  
    
      **
      =**  :  왼쪽, 오른쪽 피연산자의 비트 OR를 구해서 왼쪽 피연산자에 저장합니다.
    
  


^=  :  왼쪽, 오른쪽 피연산자의 비트 XOR를 구해서 왼쪽 피연산자에 저장합니다.

대입 연산자에 대한 정리 글

화살표 연산자

화살표 연산자 같은 경우는 람다에서 주로 사용되며 식별자 없이 실행가능한 함수를 가리킬 때? 매개변수들이 무엇인지 가리켜? 주려고 사용한다.

Print print = new Print(i){
    System.out.println(i);
};

//윗 부분을 아래처럼 나타낼 수 있다.
Print print = (i) -&gt; System.out.println(i);


이렇게 쓰면 장점이 가독성이 높아진다는 것입니다.

3항 연산자

3항 연산자의 경우에는 조건식 1, 2, 모두 세 개의 피연산자를 필요로 하는 삼항 연산자이며, 조건 연산자 중 하나뿐이다.

조건식 ? 식1 : 식2


조건 연산자의 결과가 true이면 식1이, false 이면 식2가 연산결과가 된다.가독성을 높이기 위해 괄호를 사용하기도 한다.

일단 이것의 장점은 if문에 있어 조건연산자가 간략하다는 것이다.

연산자 우선순위


  산술 &gt; 비교 &gt; 논리 &gt;대입, 대입은 제일 마지막에 수행된다.
  단항(1) &gt; 이항(2) &gt; 삼항(3), 단항의 연산자의 우선순위가 이항 연산자보다 높다.
  단항 연산자와 대입 연산자를 제외한 모든 연산의 진행방향은 왼쪽에서 오른쪽이다.



  
    
      종류
      결합규칙
      연산자
      우선순위
    
  
  
    
      단향 연산자
      &lt;—
      ++, –, +, =, ~, ! (type)
      높음
    
    
      산술 연산자
      —&gt;
      *, /, %
       
    
    
       
      —&gt;
      +, -
       
    
    
       
      —&gt;
      «, »
       
    
    
      비교연산자
      —&gt;
      &lt;, &gt;, &lt;=, &gt;=, instanceof
       
    
    
       
      —&gt;
      ==, !=
       
    
    
      논리연산자
      —&gt;
      &amp;
       
    
    
       
      —&gt;
      ^
       
    
    
       
      —&gt;
      |
       
    
    
       
      —&gt;
      &amp;&amp;
       
    
    
       
      —&gt;
      ||
       
    
    
      삼항연산자
      —&gt;
      ? :
       
    
    
      대입 연산자
      &lt;—
      =, +=, -=, *=, /=, %=, «=, »=, &amp;=, ^=, |=
      낮음
    
  


                        </a>
                        <div class="info-post">
                                <a href="/Java" class="category">Java</a>
                            
                                <span class="date">· 2023-01-06</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        </ul>
    
</div>
<div class="pagination">
    <nav class="pagination-container">
        <button class="pagination-button" id="prev-button" aria-label="Previous page" title="Previous page">
            &lt;
        </button>
    
        <div id="pagination-numbers"></div>
      
        <button class="pagination-button" id="next-button" aria-label="Next page" title="Next page">
            &gt;
        </button>
    </nav>
</div>
                
            </div>
        </div>
        <div id="search">
    <div class="wave"></div>
    <div class="wave"></div>
    <div class="wave"></div>

    <div class="search-box">
        <mark>Touch background to close</mark>
        <div class="input-box">
            <input id="search-input" type="search" tabindex="1" spellcheck="false" placeholder="Search...">
            <button id="btn-clear">
                <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 384 512"><path d="M342.6 150.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L192 210.7 86.6 105.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3L146.7 256 41.4 361.4c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0L192 301.3 297.4 406.6c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L237.3 256 342.6 150.6z"></path></svg>
            </button>
        </div>
        <ul id="search-result"></ul>
    </div>
</div>
    </body>
    <script defer src="/assets/js/background.js"></script>
<script defer src="https://www.googletagmanager.com/gtag/js?id="></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){ dataLayer.push(arguments); }

    gtag('js', new Date());
    gtag('config', '');
</script>
    
        <script src="/assets/js/subject.js"></script>
    
    <script src="/assets/js/common.js"></script>
    <script defer>
    var posts = [];

    

        posts.push({
            'title'    : "Index",
            'path'     : "Database > Postgresql",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/Database/Postgresql/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "Database",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/Database/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "Etc",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/Etc/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "Git",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/Git/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "Java > Live-Study",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/Java/Live-Study/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "Java",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/Java/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "Sap",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/Sap/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "Spring",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/Spring/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "PostgreSQL이란",
            'path'     : "Database > Postgresql",
            'type'     : "post",
            'tags'     : "Database, Postgresql",
            'url'      : "/Database/Postgresql/2023-01-06-postgresql.html",
            'image'    : "/assets/img/thumbnail/postgresql_thumbnail.png",
            'date'     : "2023-01-06"
        });
    

        posts.push({
            'title'    : "SSR, SSG",
            'path'     : "Etc",
            'type'     : "post",
            'tags'     : "etc, SSR, SSG",
            'url'      : "/Etc/2023-01-06-SSR,%20SSG.html",
            'image'    : "/assets/img/thumbnail/ect_thumbnail.jpg",
            'date'     : "2023-01-06"
        });
    

        posts.push({
            'title'    : "Git flow와 Jira 사용 전략",
            'path'     : "Git",
            'type'     : "post",
            'tags'     : "git, github, git flow, Jira, 협업",
            'url'      : "/Git/2023-01-06-git-flow.html",
            'image'    : "/assets/img/thumbnail/github_thumbnail.png",
            'date'     : "2023-01-06"
        });
    

        posts.push({
            'title'    : "깃허브 블로그 로컬로 돌리기",
            'path'     : "Git",
            'type'     : "post",
            'tags'     : "git, github, jekyll",
            'url'      : "/Git/2023-01-06-github-blog-local-batch.html",
            'image'    : "/assets/img/thumbnail/github_thumbnail.png",
            'date'     : "2023-01-06"
        });
    

        posts.push({
            'title'    : "Jasypt 암호화",
            'path'     : "Java",
            'type'     : "post",
            'tags'     : "java, 백기선 Live Study",
            'url'      : "/Java/2023-01-06-jasypt.html",
            'image'    : "/assets/img/thumbnail/java_thumbnail.png",
            'date'     : "2023-01-06"
        });
    

        posts.push({
            'title'    : "JVM, 자바 코드 실행 과정",
            'path'     : "Java > Live-Study",
            'type'     : "post",
            'tags'     : "java, 백기선 Live Study",
            'url'      : "/Java/Live-Study/2023-01-06-live-study.html",
            'image'    : "/assets/img/thumbnail/java_thumbnail.png",
            'date'     : "2023-01-06"
        });
    

        posts.push({
            'title'    : "자바의 애노테이션",
            'path'     : "Java > Live-Study",
            'type'     : "post",
            'tags'     : "java, 백기선 Live Study",
            'url'      : "/Java/Live-Study/2023-01-06-live-study12.html",
            'image'    : "/assets/img/thumbnail/java_thumbnail.png",
            'date'     : "2023-01-06"
        });
    

        posts.push({
            'title'    : "primitive 타입, 변수, 배열",
            'path'     : "Java > Live-Study",
            'type'     : "post",
            'tags'     : "java, 백기선 Live Study",
            'url'      : "/Java/Live-Study/2023-01-06-live-study2.html",
            'image'    : "/assets/img/thumbnail/java_thumbnail.png",
            'date'     : "2023-01-06"
        });
    

        posts.push({
            'title'    : "연산자",
            'path'     : "Java > Live-Study",
            'type'     : "post",
            'tags'     : "java, 백기선 Live Study",
            'url'      : "/Java/Live-Study/2023-01-06-live-study3.html",
            'image'    : "/assets/img/thumbnail/java_thumbnail.png",
            'date'     : "2023-01-06"
        });
    

        posts.push({
            'title'    : "제어문",
            'path'     : "Java > Live-Study",
            'type'     : "post",
            'tags'     : "java, 백기선 Live Study",
            'url'      : "/Java/Live-Study/2023-01-06-live-study4.html",
            'image'    : "/assets/img/thumbnail/java_thumbnail.png",
            'date'     : "2023-01-06"
        });
    

        posts.push({
            'title'    : "자바의 Class",
            'path'     : "Java > Live-Study",
            'type'     : "post",
            'tags'     : "java, 백기선 Live Study",
            'url'      : "/Java/Live-Study/2023-01-06-live-study5.html",
            'image'    : "/assets/img/thumbnail/java_thumbnail.png",
            'date'     : "2023-01-06"
        });
    

        posts.push({
            'title'    : "자바의 상속",
            'path'     : "Java > Live-Study",
            'type'     : "post",
            'tags'     : "java, 백기선 Live Study",
            'url'      : "/Java/Live-Study/2023-01-06-live-study6.html",
            'image'    : "/assets/img/thumbnail/java_thumbnail.png",
            'date'     : "2023-01-06"
        });
    

        posts.push({
            'title'    : "자바의 패키지",
            'path'     : "Java > Live-Study",
            'type'     : "post",
            'tags'     : "java, 백기선 Live Study",
            'url'      : "/Java/Live-Study/2023-01-06-live-study7.html",
            'image'    : "/assets/img/thumbnail/java_thumbnail.png",
            'date'     : "2023-01-06"
        });
    

        posts.push({
            'title'    : "자바의 인터페이스",
            'path'     : "Java > Live-Study",
            'type'     : "post",
            'tags'     : "java, 백기선 Live Study",
            'url'      : "/Java/Live-Study/2023-01-06-live-study8.html",
            'image'    : "/assets/img/thumbnail/java_thumbnail.png",
            'date'     : "2023-01-06"
        });
    

        posts.push({
            'title'    : "자바의 예외 처리",
            'path'     : "Java > Live-Study",
            'type'     : "post",
            'tags'     : "java, 백기선 Live Study",
            'url'      : "/Java/Live-Study/2023-01-06-live-study9.html",
            'image'    : "/assets/img/thumbnail/java_thumbnail.png",
            'date'     : "2023-01-06"
        });
    

        posts.push({
            'title'    : "OData V2 Model",
            'path'     : "Sap > sapui5",
            'type'     : "post",
            'tags'     : "SAP, SAP-ui5, V2-Model",
            'url'      : "/Sap/sapui5/2023-01-06-OData%20V2%20Model.html",
            'image'    : "/assets/img/thumbnail/sap_thumbnail.png",
            'date'     : "2023-01-06"
        });
    

        posts.push({
            'title'    : "SAP UI5 란",
            'path'     : "Sap > sapui5",
            'type'     : "post",
            'tags'     : "SAP, SAP-ui5, V2-Model",
            'url'      : "/Sap/sapui5/2023-01-06-sapui5.html",
            'image'    : "/assets/img/thumbnail/sap_thumbnail.png",
            'date'     : "2023-01-06"
        });
    

        posts.push({
            'title'    : "DTO 처리방법",
            'path'     : "Spring",
            'type'     : "post",
            'tags'     : "spring, DTO, TICKET-EXPEDITIONARY-FORCE",
            'url'      : "/Spring/2023-01-06-DTO.html",
            'image'    : "/assets/img/thumbnail/spring_thumbnail.webp",
            'date'     : "2023-01-06"
        });
    

        posts.push({
            'title'    : "내가 적어보는 Hateoas 정리",
            'path'     : "Spring",
            'type'     : "post",
            'tags'     : "spring, spring Doc, Hateoas, TICKET-EXPEDITIONARY-FORCE",
            'url'      : "/Spring/2023-01-06-Hateoas.html",
            'image'    : "/assets/img/thumbnail/spring_thumbnail.webp",
            'date'     : "2023-01-06"
        });
    

        posts.push({
            'title'    : "엔티티 설정",
            'path'     : "Spring > TICKET-EXPEDITIONARY-FORCE",
            'type'     : "post",
            'tags'     : "spring, JPA, entity, TICKET-EXPEDITIONARY-FORCE",
            'url'      : "/Spring/TICKET-EXPEDITIONARY-FORCE/2023-01-06-SETTING-ACCOUNT-ENTITY.html",
            'image'    : "/assets/img/thumbnail/spring_thumbnail.webp",
            'date'     : "2023-01-06"
        });
    

        posts.push({
            'title'    : "티켓 원정대 출발!",
            'path'     : "Spring > TICKET-EXPEDITIONARY-FORCE",
            'type'     : "post",
            'tags'     : "spring, JPA, entity, TICKET-EXPEDITIONARY-FORCE",
            'url'      : "/Spring/TICKET-EXPEDITIONARY-FORCE/2023-01-06-TICKET-EXPEDITIONARY-FORCE-start.html",
            'image'    : "/assets/img/thumbnail/spring_thumbnail.webp",
            'date'     : "2023-01-06"
        });
    

    searchPost(posts);

    
</script>
</html>
